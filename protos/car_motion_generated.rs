// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protos {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod car_motion_data {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum CarMotionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CarMotionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CarMotionData<'a> {
  type Inner = CarMotionData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CarMotionData<'a> {
  pub const VT_M_WORLD_POSITION_X: flatbuffers::VOffsetT = 4;
  pub const VT_M_WORLD_POSITION_Y: flatbuffers::VOffsetT = 6;
  pub const VT_M_WORLD_POSITION_Z: flatbuffers::VOffsetT = 8;
  pub const VT_M_WORLD_VELOCITY_X: flatbuffers::VOffsetT = 10;
  pub const VT_M_WORLD_VELOCITY_Y: flatbuffers::VOffsetT = 12;
  pub const VT_M_WORLD_VELOCITY_Z: flatbuffers::VOffsetT = 14;
  pub const VT_M_WORLD_FORWARD_DIR_X: flatbuffers::VOffsetT = 16;
  pub const VT_M_WORLD_FORWARD_DIR_Y: flatbuffers::VOffsetT = 18;
  pub const VT_M_WORLD_FORWARD_DIR_Z: flatbuffers::VOffsetT = 20;
  pub const VT_M_WORLD_RIGHT_DIR_X: flatbuffers::VOffsetT = 22;
  pub const VT_M_WORLD_RIGHT_DIR_Y: flatbuffers::VOffsetT = 24;
  pub const VT_M_WORLD_RIGHT_DIR_Z: flatbuffers::VOffsetT = 26;
  pub const VT_M_G_FORCE_LATERAL: flatbuffers::VOffsetT = 28;
  pub const VT_M_G_FORCE_LONGITUDINAL: flatbuffers::VOffsetT = 30;
  pub const VT_M_G_FORCE_VERTICAL: flatbuffers::VOffsetT = 32;
  pub const VT_M_YAW: flatbuffers::VOffsetT = 34;
  pub const VT_M_PITCH: flatbuffers::VOffsetT = 36;
  pub const VT_M_ROLL: flatbuffers::VOffsetT = 38;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CarMotionData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CarMotionDataArgs
  ) -> flatbuffers::WIPOffset<CarMotionData<'bldr>> {
    let mut builder = CarMotionDataBuilder::new(_fbb);
    builder.add_m_roll(args.m_roll);
    builder.add_m_pitch(args.m_pitch);
    builder.add_m_yaw(args.m_yaw);
    builder.add_m_g_force_vertical(args.m_g_force_vertical);
    builder.add_m_g_force_longitudinal(args.m_g_force_longitudinal);
    builder.add_m_g_force_lateral(args.m_g_force_lateral);
    builder.add_m_world_velocity_z(args.m_world_velocity_z);
    builder.add_m_world_velocity_y(args.m_world_velocity_y);
    builder.add_m_world_velocity_x(args.m_world_velocity_x);
    builder.add_m_world_position_z(args.m_world_position_z);
    builder.add_m_world_position_y(args.m_world_position_y);
    builder.add_m_world_position_x(args.m_world_position_x);
    builder.add_m_world_right_dir_z(args.m_world_right_dir_z);
    builder.add_m_world_right_dir_y(args.m_world_right_dir_y);
    builder.add_m_world_right_dir_x(args.m_world_right_dir_x);
    builder.add_m_world_forward_dir_z(args.m_world_forward_dir_z);
    builder.add_m_world_forward_dir_y(args.m_world_forward_dir_y);
    builder.add_m_world_forward_dir_x(args.m_world_forward_dir_x);
    builder.finish()
  }


  #[inline]
  pub fn m_world_position_x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_POSITION_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_position_y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_POSITION_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_position_z(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_POSITION_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_velocity_x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_velocity_y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_velocity_z(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_Z, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_world_forward_dir_x(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_world_forward_dir_y(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_world_forward_dir_z(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_Z, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_world_right_dir_x(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_world_right_dir_y(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_world_right_dir_z(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_Z, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_g_force_lateral(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_G_FORCE_LATERAL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_g_force_longitudinal(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_G_FORCE_LONGITUDINAL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_g_force_vertical(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_G_FORCE_VERTICAL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_yaw(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_YAW, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_pitch(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_PITCH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_roll(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CarMotionData::VT_M_ROLL, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CarMotionData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("m_world_position_x", Self::VT_M_WORLD_POSITION_X, false)?
     .visit_field::<f32>("m_world_position_y", Self::VT_M_WORLD_POSITION_Y, false)?
     .visit_field::<f32>("m_world_position_z", Self::VT_M_WORLD_POSITION_Z, false)?
     .visit_field::<f32>("m_world_velocity_x", Self::VT_M_WORLD_VELOCITY_X, false)?
     .visit_field::<f32>("m_world_velocity_y", Self::VT_M_WORLD_VELOCITY_Y, false)?
     .visit_field::<f32>("m_world_velocity_z", Self::VT_M_WORLD_VELOCITY_Z, false)?
     .visit_field::<i16>("m_world_forward_dir_x", Self::VT_M_WORLD_FORWARD_DIR_X, false)?
     .visit_field::<i16>("m_world_forward_dir_y", Self::VT_M_WORLD_FORWARD_DIR_Y, false)?
     .visit_field::<i16>("m_world_forward_dir_z", Self::VT_M_WORLD_FORWARD_DIR_Z, false)?
     .visit_field::<i16>("m_world_right_dir_x", Self::VT_M_WORLD_RIGHT_DIR_X, false)?
     .visit_field::<i16>("m_world_right_dir_y", Self::VT_M_WORLD_RIGHT_DIR_Y, false)?
     .visit_field::<i16>("m_world_right_dir_z", Self::VT_M_WORLD_RIGHT_DIR_Z, false)?
     .visit_field::<f32>("m_g_force_lateral", Self::VT_M_G_FORCE_LATERAL, false)?
     .visit_field::<f32>("m_g_force_longitudinal", Self::VT_M_G_FORCE_LONGITUDINAL, false)?
     .visit_field::<f32>("m_g_force_vertical", Self::VT_M_G_FORCE_VERTICAL, false)?
     .visit_field::<f32>("m_yaw", Self::VT_M_YAW, false)?
     .visit_field::<f32>("m_pitch", Self::VT_M_PITCH, false)?
     .visit_field::<f32>("m_roll", Self::VT_M_ROLL, false)?
     .finish();
    Ok(())
  }
}
pub struct CarMotionDataArgs {
    pub m_world_position_x: f32,
    pub m_world_position_y: f32,
    pub m_world_position_z: f32,
    pub m_world_velocity_x: f32,
    pub m_world_velocity_y: f32,
    pub m_world_velocity_z: f32,
    pub m_world_forward_dir_x: i16,
    pub m_world_forward_dir_y: i16,
    pub m_world_forward_dir_z: i16,
    pub m_world_right_dir_x: i16,
    pub m_world_right_dir_y: i16,
    pub m_world_right_dir_z: i16,
    pub m_g_force_lateral: f32,
    pub m_g_force_longitudinal: f32,
    pub m_g_force_vertical: f32,
    pub m_yaw: f32,
    pub m_pitch: f32,
    pub m_roll: f32,
}
impl<'a> Default for CarMotionDataArgs {
  #[inline]
  fn default() -> Self {
    CarMotionDataArgs {
      m_world_position_x: 0.0,
      m_world_position_y: 0.0,
      m_world_position_z: 0.0,
      m_world_velocity_x: 0.0,
      m_world_velocity_y: 0.0,
      m_world_velocity_z: 0.0,
      m_world_forward_dir_x: 0,
      m_world_forward_dir_y: 0,
      m_world_forward_dir_z: 0,
      m_world_right_dir_x: 0,
      m_world_right_dir_y: 0,
      m_world_right_dir_z: 0,
      m_g_force_lateral: 0.0,
      m_g_force_longitudinal: 0.0,
      m_g_force_vertical: 0.0,
      m_yaw: 0.0,
      m_pitch: 0.0,
      m_roll: 0.0,
    }
  }
}

pub struct CarMotionDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CarMotionDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_world_position_x(&mut self, m_world_position_x: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_POSITION_X, m_world_position_x, 0.0);
  }
  #[inline]
  pub fn add_m_world_position_y(&mut self, m_world_position_y: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_POSITION_Y, m_world_position_y, 0.0);
  }
  #[inline]
  pub fn add_m_world_position_z(&mut self, m_world_position_z: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_POSITION_Z, m_world_position_z, 0.0);
  }
  #[inline]
  pub fn add_m_world_velocity_x(&mut self, m_world_velocity_x: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_X, m_world_velocity_x, 0.0);
  }
  #[inline]
  pub fn add_m_world_velocity_y(&mut self, m_world_velocity_y: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_Y, m_world_velocity_y, 0.0);
  }
  #[inline]
  pub fn add_m_world_velocity_z(&mut self, m_world_velocity_z: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_WORLD_VELOCITY_Z, m_world_velocity_z, 0.0);
  }
  #[inline]
  pub fn add_m_world_forward_dir_x(&mut self, m_world_forward_dir_x: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_X, m_world_forward_dir_x, 0);
  }
  #[inline]
  pub fn add_m_world_forward_dir_y(&mut self, m_world_forward_dir_y: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_Y, m_world_forward_dir_y, 0);
  }
  #[inline]
  pub fn add_m_world_forward_dir_z(&mut self, m_world_forward_dir_z: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_FORWARD_DIR_Z, m_world_forward_dir_z, 0);
  }
  #[inline]
  pub fn add_m_world_right_dir_x(&mut self, m_world_right_dir_x: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_X, m_world_right_dir_x, 0);
  }
  #[inline]
  pub fn add_m_world_right_dir_y(&mut self, m_world_right_dir_y: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_Y, m_world_right_dir_y, 0);
  }
  #[inline]
  pub fn add_m_world_right_dir_z(&mut self, m_world_right_dir_z: i16) {
    self.fbb_.push_slot::<i16>(CarMotionData::VT_M_WORLD_RIGHT_DIR_Z, m_world_right_dir_z, 0);
  }
  #[inline]
  pub fn add_m_g_force_lateral(&mut self, m_g_force_lateral: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_G_FORCE_LATERAL, m_g_force_lateral, 0.0);
  }
  #[inline]
  pub fn add_m_g_force_longitudinal(&mut self, m_g_force_longitudinal: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_G_FORCE_LONGITUDINAL, m_g_force_longitudinal, 0.0);
  }
  #[inline]
  pub fn add_m_g_force_vertical(&mut self, m_g_force_vertical: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_G_FORCE_VERTICAL, m_g_force_vertical, 0.0);
  }
  #[inline]
  pub fn add_m_yaw(&mut self, m_yaw: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_YAW, m_yaw, 0.0);
  }
  #[inline]
  pub fn add_m_pitch(&mut self, m_pitch: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_PITCH, m_pitch, 0.0);
  }
  #[inline]
  pub fn add_m_roll(&mut self, m_roll: f32) {
    self.fbb_.push_slot::<f32>(CarMotionData::VT_M_ROLL, m_roll, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CarMotionDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CarMotionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CarMotionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CarMotionData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CarMotionData");
      ds.field("m_world_position_x", &self.m_world_position_x());
      ds.field("m_world_position_y", &self.m_world_position_y());
      ds.field("m_world_position_z", &self.m_world_position_z());
      ds.field("m_world_velocity_x", &self.m_world_velocity_x());
      ds.field("m_world_velocity_y", &self.m_world_velocity_y());
      ds.field("m_world_velocity_z", &self.m_world_velocity_z());
      ds.field("m_world_forward_dir_x", &self.m_world_forward_dir_x());
      ds.field("m_world_forward_dir_y", &self.m_world_forward_dir_y());
      ds.field("m_world_forward_dir_z", &self.m_world_forward_dir_z());
      ds.field("m_world_right_dir_x", &self.m_world_right_dir_x());
      ds.field("m_world_right_dir_y", &self.m_world_right_dir_y());
      ds.field("m_world_right_dir_z", &self.m_world_right_dir_z());
      ds.field("m_g_force_lateral", &self.m_g_force_lateral());
      ds.field("m_g_force_longitudinal", &self.m_g_force_longitudinal());
      ds.field("m_g_force_vertical", &self.m_g_force_vertical());
      ds.field("m_yaw", &self.m_yaw());
      ds.field("m_pitch", &self.m_pitch());
      ds.field("m_roll", &self.m_roll());
      ds.finish()
  }
}
pub enum PacketMotionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PacketMotionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PacketMotionData<'a> {
  type Inner = PacketMotionData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PacketMotionData<'a> {
  pub const VT_M_CAR_MOTION_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PacketMotionData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketMotionDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PacketMotionData<'bldr>> {
    let mut builder = PacketMotionDataBuilder::new(_fbb);
    if let Some(x) = args.m_car_motion_data { builder.add_m_car_motion_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn m_car_motion_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CarMotionData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CarMotionData>>>>(PacketMotionData::VT_M_CAR_MOTION_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PacketMotionData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<CarMotionData>>>>("m_car_motion_data", Self::VT_M_CAR_MOTION_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketMotionDataArgs<'a> {
    pub m_car_motion_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<CarMotionData<'a>>>>>,
}
impl<'a> Default for PacketMotionDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketMotionDataArgs {
      m_car_motion_data: None,
    }
  }
}

pub struct PacketMotionDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketMotionDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_car_motion_data(&mut self, m_car_motion_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<CarMotionData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketMotionData::VT_M_CAR_MOTION_DATA, m_car_motion_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketMotionDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketMotionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PacketMotionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PacketMotionData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PacketMotionData");
      ds.field("m_car_motion_data", &self.m_car_motion_data());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PacketMotionData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_motion_data_unchecked`.
pub fn root_as_packet_motion_data(buf: &[u8]) -> Result<PacketMotionData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PacketMotionData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PacketMotionData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_packet_motion_data_unchecked`.
pub fn size_prefixed_root_as_packet_motion_data(buf: &[u8]) -> Result<PacketMotionData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PacketMotionData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PacketMotionData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_motion_data_unchecked`.
pub fn root_as_packet_motion_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketMotionData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PacketMotionData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PacketMotionData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_motion_data_unchecked`.
pub fn size_prefixed_root_as_packet_motion_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketMotionData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PacketMotionData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PacketMotionData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PacketMotionData`.
pub unsafe fn root_as_packet_motion_data_unchecked(buf: &[u8]) -> PacketMotionData {
  flatbuffers::root_unchecked::<PacketMotionData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PacketMotionData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PacketMotionData`.
pub unsafe fn size_prefixed_root_as_packet_motion_data_unchecked(buf: &[u8]) -> PacketMotionData {
  flatbuffers::size_prefixed_root_unchecked::<PacketMotionData>(buf)
}
#[inline]
pub fn finish_packet_motion_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PacketMotionData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_motion_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<PacketMotionData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod car_motion_data
}  // pub mod protos

