// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protos {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod event_data {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EVENT_DATA_DETAILS_UNION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EVENT_DATA_DETAILS_UNION: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_DATA_DETAILS_UNION: [EventDataDetailsUnion; 13] = [
  EventDataDetailsUnion::NONE,
  EventDataDetailsUnion::FastestLap,
  EventDataDetailsUnion::Retirement,
  EventDataDetailsUnion::TeamMateInPits,
  EventDataDetailsUnion::RaceWinner,
  EventDataDetailsUnion::Penalty,
  EventDataDetailsUnion::SpeedTrap,
  EventDataDetailsUnion::StartLights,
  EventDataDetailsUnion::DriveThroughPenaltyServed,
  EventDataDetailsUnion::StopGoPenaltyServed,
  EventDataDetailsUnion::Flashback,
  EventDataDetailsUnion::Buttons,
  EventDataDetailsUnion::Overtake,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventDataDetailsUnion(pub u8);
#[allow(non_upper_case_globals)]
impl EventDataDetailsUnion {
  pub const NONE: Self = Self(0);
  pub const FastestLap: Self = Self(1);
  pub const Retirement: Self = Self(2);
  pub const TeamMateInPits: Self = Self(3);
  pub const RaceWinner: Self = Self(4);
  pub const Penalty: Self = Self(5);
  pub const SpeedTrap: Self = Self(6);
  pub const StartLights: Self = Self(7);
  pub const DriveThroughPenaltyServed: Self = Self(8);
  pub const StopGoPenaltyServed: Self = Self(9);
  pub const Flashback: Self = Self(10);
  pub const Buttons: Self = Self(11);
  pub const Overtake: Self = Self(12);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::FastestLap,
    Self::Retirement,
    Self::TeamMateInPits,
    Self::RaceWinner,
    Self::Penalty,
    Self::SpeedTrap,
    Self::StartLights,
    Self::DriveThroughPenaltyServed,
    Self::StopGoPenaltyServed,
    Self::Flashback,
    Self::Buttons,
    Self::Overtake,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::FastestLap => Some("FastestLap"),
      Self::Retirement => Some("Retirement"),
      Self::TeamMateInPits => Some("TeamMateInPits"),
      Self::RaceWinner => Some("RaceWinner"),
      Self::Penalty => Some("Penalty"),
      Self::SpeedTrap => Some("SpeedTrap"),
      Self::StartLights => Some("StartLights"),
      Self::DriveThroughPenaltyServed => Some("DriveThroughPenaltyServed"),
      Self::StopGoPenaltyServed => Some("StopGoPenaltyServed"),
      Self::Flashback => Some("Flashback"),
      Self::Buttons => Some("Buttons"),
      Self::Overtake => Some("Overtake"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EventDataDetailsUnion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EventDataDetailsUnion {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EventDataDetailsUnion {
    type Output = EventDataDetailsUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EventDataDetailsUnion {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EventDataDetailsUnion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EventDataDetailsUnion {}
pub struct EventDataDetailsUnionUnionTableOffset {}

pub enum FastestLapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FastestLap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FastestLap<'a> {
  type Inner = FastestLap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FastestLap<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;
  pub const VT_LAP_TIME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FastestLap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FastestLapArgs
  ) -> flatbuffers::WIPOffset<FastestLap<'bldr>> {
    let mut builder = FastestLapBuilder::new(_fbb);
    builder.add_lap_time(args.lap_time);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FastestLap::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lap_time(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FastestLap::VT_LAP_TIME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FastestLap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .visit_field::<f32>("lap_time", Self::VT_LAP_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct FastestLapArgs {
    pub vehicle_idx: u8,
    pub lap_time: f32,
}
impl<'a> Default for FastestLapArgs {
  #[inline]
  fn default() -> Self {
    FastestLapArgs {
      vehicle_idx: 0,
      lap_time: 0.0,
    }
  }
}

pub struct FastestLapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FastestLapBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(FastestLap::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn add_lap_time(&mut self, lap_time: f32) {
    self.fbb_.push_slot::<f32>(FastestLap::VT_LAP_TIME, lap_time, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FastestLapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FastestLapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FastestLap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FastestLap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FastestLap");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.field("lap_time", &self.lap_time());
      ds.finish()
  }
}
pub enum RetirementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Retirement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Retirement<'a> {
  type Inner = Retirement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Retirement<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Retirement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RetirementArgs
  ) -> flatbuffers::WIPOffset<Retirement<'bldr>> {
    let mut builder = RetirementBuilder::new(_fbb);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Retirement::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Retirement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct RetirementArgs {
    pub vehicle_idx: u8,
}
impl<'a> Default for RetirementArgs {
  #[inline]
  fn default() -> Self {
    RetirementArgs {
      vehicle_idx: 0,
    }
  }
}

pub struct RetirementBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RetirementBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(Retirement::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RetirementBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RetirementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Retirement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Retirement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Retirement");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.finish()
  }
}
pub enum TeamMateInPitsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TeamMateInPits<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TeamMateInPits<'a> {
  type Inner = TeamMateInPits<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TeamMateInPits<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TeamMateInPits { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TeamMateInPitsArgs
  ) -> flatbuffers::WIPOffset<TeamMateInPits<'bldr>> {
    let mut builder = TeamMateInPitsBuilder::new(_fbb);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TeamMateInPits::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TeamMateInPits<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct TeamMateInPitsArgs {
    pub vehicle_idx: u8,
}
impl<'a> Default for TeamMateInPitsArgs {
  #[inline]
  fn default() -> Self {
    TeamMateInPitsArgs {
      vehicle_idx: 0,
    }
  }
}

pub struct TeamMateInPitsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TeamMateInPitsBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(TeamMateInPits::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TeamMateInPitsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TeamMateInPitsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TeamMateInPits<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TeamMateInPits<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TeamMateInPits");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.finish()
  }
}
pub enum RaceWinnerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RaceWinner<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RaceWinner<'a> {
  type Inner = RaceWinner<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RaceWinner<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RaceWinner { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RaceWinnerArgs
  ) -> flatbuffers::WIPOffset<RaceWinner<'bldr>> {
    let mut builder = RaceWinnerBuilder::new(_fbb);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(RaceWinner::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RaceWinner<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct RaceWinnerArgs {
    pub vehicle_idx: u8,
}
impl<'a> Default for RaceWinnerArgs {
  #[inline]
  fn default() -> Self {
    RaceWinnerArgs {
      vehicle_idx: 0,
    }
  }
}

pub struct RaceWinnerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RaceWinnerBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(RaceWinner::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RaceWinnerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RaceWinnerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RaceWinner<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RaceWinner<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RaceWinner");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.finish()
  }
}
pub enum PenaltyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Penalty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Penalty<'a> {
  type Inner = Penalty<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Penalty<'a> {
  pub const VT_PENALTY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_INFRINGEMENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 8;
  pub const VT_OTHER_VEHICLE_IDX: flatbuffers::VOffsetT = 10;
  pub const VT_TIME: flatbuffers::VOffsetT = 12;
  pub const VT_LAP_NUM: flatbuffers::VOffsetT = 14;
  pub const VT_PLACES_GAINED: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Penalty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PenaltyArgs
  ) -> flatbuffers::WIPOffset<Penalty<'bldr>> {
    let mut builder = PenaltyBuilder::new(_fbb);
    builder.add_places_gained(args.places_gained);
    builder.add_lap_num(args.lap_num);
    builder.add_time(args.time);
    builder.add_other_vehicle_idx(args.other_vehicle_idx);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.add_infringement_type(args.infringement_type);
    builder.add_penalty_type(args.penalty_type);
    builder.finish()
  }


  #[inline]
  pub fn penalty_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_PENALTY_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn infringement_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_INFRINGEMENT_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn other_vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_OTHER_VEHICLE_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn time(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_TIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lap_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_LAP_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn places_gained(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Penalty::VT_PLACES_GAINED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Penalty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("penalty_type", Self::VT_PENALTY_TYPE, false)?
     .visit_field::<u8>("infringement_type", Self::VT_INFRINGEMENT_TYPE, false)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .visit_field::<u8>("other_vehicle_idx", Self::VT_OTHER_VEHICLE_IDX, false)?
     .visit_field::<u8>("time", Self::VT_TIME, false)?
     .visit_field::<u8>("lap_num", Self::VT_LAP_NUM, false)?
     .visit_field::<u8>("places_gained", Self::VT_PLACES_GAINED, false)?
     .finish();
    Ok(())
  }
}
pub struct PenaltyArgs {
    pub penalty_type: u8,
    pub infringement_type: u8,
    pub vehicle_idx: u8,
    pub other_vehicle_idx: u8,
    pub time: u8,
    pub lap_num: u8,
    pub places_gained: u8,
}
impl<'a> Default for PenaltyArgs {
  #[inline]
  fn default() -> Self {
    PenaltyArgs {
      penalty_type: 0,
      infringement_type: 0,
      vehicle_idx: 0,
      other_vehicle_idx: 0,
      time: 0,
      lap_num: 0,
      places_gained: 0,
    }
  }
}

pub struct PenaltyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PenaltyBuilder<'a, 'b> {
  #[inline]
  pub fn add_penalty_type(&mut self, penalty_type: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_PENALTY_TYPE, penalty_type, 0);
  }
  #[inline]
  pub fn add_infringement_type(&mut self, infringement_type: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_INFRINGEMENT_TYPE, infringement_type, 0);
  }
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn add_other_vehicle_idx(&mut self, other_vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_OTHER_VEHICLE_IDX, other_vehicle_idx, 0);
  }
  #[inline]
  pub fn add_time(&mut self, time: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_TIME, time, 0);
  }
  #[inline]
  pub fn add_lap_num(&mut self, lap_num: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_LAP_NUM, lap_num, 0);
  }
  #[inline]
  pub fn add_places_gained(&mut self, places_gained: u8) {
    self.fbb_.push_slot::<u8>(Penalty::VT_PLACES_GAINED, places_gained, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PenaltyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PenaltyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Penalty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Penalty<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Penalty");
      ds.field("penalty_type", &self.penalty_type());
      ds.field("infringement_type", &self.infringement_type());
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.field("other_vehicle_idx", &self.other_vehicle_idx());
      ds.field("time", &self.time());
      ds.field("lap_num", &self.lap_num());
      ds.field("places_gained", &self.places_gained());
      ds.finish()
  }
}
pub enum SpeedTrapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpeedTrap<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpeedTrap<'a> {
  type Inner = SpeedTrap<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SpeedTrap<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;
  pub const VT_SPEED: flatbuffers::VOffsetT = 6;
  pub const VT_IS_OVERALL_FASTEST_IN_SESSION: flatbuffers::VOffsetT = 8;
  pub const VT_IS_DRIVER_FASTEST_IN_SESSION: flatbuffers::VOffsetT = 10;
  pub const VT_FASTEST_VEHICLE_IDX_IN_SESSION: flatbuffers::VOffsetT = 12;
  pub const VT_FASTEST_SPEED_IN_SESSION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpeedTrap { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpeedTrapArgs
  ) -> flatbuffers::WIPOffset<SpeedTrap<'bldr>> {
    let mut builder = SpeedTrapBuilder::new(_fbb);
    builder.add_fastest_speed_in_session(args.fastest_speed_in_session);
    builder.add_speed(args.speed);
    builder.add_fastest_vehicle_idx_in_session(args.fastest_vehicle_idx_in_session);
    builder.add_is_driver_fastest_in_session(args.is_driver_fastest_in_session);
    builder.add_is_overall_fastest_in_session(args.is_overall_fastest_in_session);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SpeedTrap::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn speed(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SpeedTrap::VT_SPEED, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn is_overall_fastest_in_session(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SpeedTrap::VT_IS_OVERALL_FASTEST_IN_SESSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_driver_fastest_in_session(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SpeedTrap::VT_IS_DRIVER_FASTEST_IN_SESSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fastest_vehicle_idx_in_session(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(SpeedTrap::VT_FASTEST_VEHICLE_IDX_IN_SESSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fastest_speed_in_session(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SpeedTrap::VT_FASTEST_SPEED_IN_SESSION, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SpeedTrap<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .visit_field::<f32>("speed", Self::VT_SPEED, false)?
     .visit_field::<u8>("is_overall_fastest_in_session", Self::VT_IS_OVERALL_FASTEST_IN_SESSION, false)?
     .visit_field::<u8>("is_driver_fastest_in_session", Self::VT_IS_DRIVER_FASTEST_IN_SESSION, false)?
     .visit_field::<u8>("fastest_vehicle_idx_in_session", Self::VT_FASTEST_VEHICLE_IDX_IN_SESSION, false)?
     .visit_field::<f32>("fastest_speed_in_session", Self::VT_FASTEST_SPEED_IN_SESSION, false)?
     .finish();
    Ok(())
  }
}
pub struct SpeedTrapArgs {
    pub vehicle_idx: u8,
    pub speed: f32,
    pub is_overall_fastest_in_session: u8,
    pub is_driver_fastest_in_session: u8,
    pub fastest_vehicle_idx_in_session: u8,
    pub fastest_speed_in_session: f32,
}
impl<'a> Default for SpeedTrapArgs {
  #[inline]
  fn default() -> Self {
    SpeedTrapArgs {
      vehicle_idx: 0,
      speed: 0.0,
      is_overall_fastest_in_session: 0,
      is_driver_fastest_in_session: 0,
      fastest_vehicle_idx_in_session: 0,
      fastest_speed_in_session: 0.0,
    }
  }
}

pub struct SpeedTrapBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpeedTrapBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(SpeedTrap::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn add_speed(&mut self, speed: f32) {
    self.fbb_.push_slot::<f32>(SpeedTrap::VT_SPEED, speed, 0.0);
  }
  #[inline]
  pub fn add_is_overall_fastest_in_session(&mut self, is_overall_fastest_in_session: u8) {
    self.fbb_.push_slot::<u8>(SpeedTrap::VT_IS_OVERALL_FASTEST_IN_SESSION, is_overall_fastest_in_session, 0);
  }
  #[inline]
  pub fn add_is_driver_fastest_in_session(&mut self, is_driver_fastest_in_session: u8) {
    self.fbb_.push_slot::<u8>(SpeedTrap::VT_IS_DRIVER_FASTEST_IN_SESSION, is_driver_fastest_in_session, 0);
  }
  #[inline]
  pub fn add_fastest_vehicle_idx_in_session(&mut self, fastest_vehicle_idx_in_session: u8) {
    self.fbb_.push_slot::<u8>(SpeedTrap::VT_FASTEST_VEHICLE_IDX_IN_SESSION, fastest_vehicle_idx_in_session, 0);
  }
  #[inline]
  pub fn add_fastest_speed_in_session(&mut self, fastest_speed_in_session: f32) {
    self.fbb_.push_slot::<f32>(SpeedTrap::VT_FASTEST_SPEED_IN_SESSION, fastest_speed_in_session, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpeedTrapBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpeedTrapBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpeedTrap<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpeedTrap<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpeedTrap");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.field("speed", &self.speed());
      ds.field("is_overall_fastest_in_session", &self.is_overall_fastest_in_session());
      ds.field("is_driver_fastest_in_session", &self.is_driver_fastest_in_session());
      ds.field("fastest_vehicle_idx_in_session", &self.fastest_vehicle_idx_in_session());
      ds.field("fastest_speed_in_session", &self.fastest_speed_in_session());
      ds.finish()
  }
}
pub enum StartLightsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StartLights<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartLights<'a> {
  type Inner = StartLights<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StartLights<'a> {
  pub const VT_NUM_LIGHTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StartLights { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StartLightsArgs
  ) -> flatbuffers::WIPOffset<StartLights<'bldr>> {
    let mut builder = StartLightsBuilder::new(_fbb);
    builder.add_num_lights(args.num_lights);
    builder.finish()
  }


  #[inline]
  pub fn num_lights(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StartLights::VT_NUM_LIGHTS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StartLights<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("num_lights", Self::VT_NUM_LIGHTS, false)?
     .finish();
    Ok(())
  }
}
pub struct StartLightsArgs {
    pub num_lights: u8,
}
impl<'a> Default for StartLightsArgs {
  #[inline]
  fn default() -> Self {
    StartLightsArgs {
      num_lights: 0,
    }
  }
}

pub struct StartLightsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartLightsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_lights(&mut self, num_lights: u8) {
    self.fbb_.push_slot::<u8>(StartLights::VT_NUM_LIGHTS, num_lights, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StartLightsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartLightsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartLights<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StartLights<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StartLights");
      ds.field("num_lights", &self.num_lights());
      ds.finish()
  }
}
pub enum DriveThroughPenaltyServedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DriveThroughPenaltyServed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DriveThroughPenaltyServed<'a> {
  type Inner = DriveThroughPenaltyServed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DriveThroughPenaltyServed<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DriveThroughPenaltyServed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DriveThroughPenaltyServedArgs
  ) -> flatbuffers::WIPOffset<DriveThroughPenaltyServed<'bldr>> {
    let mut builder = DriveThroughPenaltyServedBuilder::new(_fbb);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(DriveThroughPenaltyServed::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DriveThroughPenaltyServed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct DriveThroughPenaltyServedArgs {
    pub vehicle_idx: u8,
}
impl<'a> Default for DriveThroughPenaltyServedArgs {
  #[inline]
  fn default() -> Self {
    DriveThroughPenaltyServedArgs {
      vehicle_idx: 0,
    }
  }
}

pub struct DriveThroughPenaltyServedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DriveThroughPenaltyServedBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(DriveThroughPenaltyServed::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DriveThroughPenaltyServedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DriveThroughPenaltyServedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DriveThroughPenaltyServed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DriveThroughPenaltyServed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DriveThroughPenaltyServed");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.finish()
  }
}
pub enum StopGoPenaltyServedOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StopGoPenaltyServed<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StopGoPenaltyServed<'a> {
  type Inner = StopGoPenaltyServed<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StopGoPenaltyServed<'a> {
  pub const VT_VEHICLE_IDX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StopGoPenaltyServed { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StopGoPenaltyServedArgs
  ) -> flatbuffers::WIPOffset<StopGoPenaltyServed<'bldr>> {
    let mut builder = StopGoPenaltyServedBuilder::new(_fbb);
    builder.add_vehicle_idx(args.vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(StopGoPenaltyServed::VT_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for StopGoPenaltyServed<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("vehicle_idx", Self::VT_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct StopGoPenaltyServedArgs {
    pub vehicle_idx: u8,
}
impl<'a> Default for StopGoPenaltyServedArgs {
  #[inline]
  fn default() -> Self {
    StopGoPenaltyServedArgs {
      vehicle_idx: 0,
    }
  }
}

pub struct StopGoPenaltyServedBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StopGoPenaltyServedBuilder<'a, 'b> {
  #[inline]
  pub fn add_vehicle_idx(&mut self, vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(StopGoPenaltyServed::VT_VEHICLE_IDX, vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StopGoPenaltyServedBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StopGoPenaltyServedBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StopGoPenaltyServed<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StopGoPenaltyServed<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StopGoPenaltyServed");
      ds.field("vehicle_idx", &self.vehicle_idx());
      ds.finish()
  }
}
pub enum FlashbackOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Flashback<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Flashback<'a> {
  type Inner = Flashback<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Flashback<'a> {
  pub const VT_FLASHBACK_FRAME_IDENTIFIER: flatbuffers::VOffsetT = 4;
  pub const VT_FLASHBACK_SESSION_TIME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Flashback { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FlashbackArgs
  ) -> flatbuffers::WIPOffset<Flashback<'bldr>> {
    let mut builder = FlashbackBuilder::new(_fbb);
    builder.add_flashback_session_time(args.flashback_session_time);
    builder.add_flashback_frame_identifier(args.flashback_frame_identifier);
    builder.finish()
  }


  #[inline]
  pub fn flashback_frame_identifier(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Flashback::VT_FLASHBACK_FRAME_IDENTIFIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flashback_session_time(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Flashback::VT_FLASHBACK_SESSION_TIME, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Flashback<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("flashback_frame_identifier", Self::VT_FLASHBACK_FRAME_IDENTIFIER, false)?
     .visit_field::<f32>("flashback_session_time", Self::VT_FLASHBACK_SESSION_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct FlashbackArgs {
    pub flashback_frame_identifier: u32,
    pub flashback_session_time: f32,
}
impl<'a> Default for FlashbackArgs {
  #[inline]
  fn default() -> Self {
    FlashbackArgs {
      flashback_frame_identifier: 0,
      flashback_session_time: 0.0,
    }
  }
}

pub struct FlashbackBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FlashbackBuilder<'a, 'b> {
  #[inline]
  pub fn add_flashback_frame_identifier(&mut self, flashback_frame_identifier: u32) {
    self.fbb_.push_slot::<u32>(Flashback::VT_FLASHBACK_FRAME_IDENTIFIER, flashback_frame_identifier, 0);
  }
  #[inline]
  pub fn add_flashback_session_time(&mut self, flashback_session_time: f32) {
    self.fbb_.push_slot::<f32>(Flashback::VT_FLASHBACK_SESSION_TIME, flashback_session_time, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FlashbackBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FlashbackBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Flashback<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Flashback<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Flashback");
      ds.field("flashback_frame_identifier", &self.flashback_frame_identifier());
      ds.field("flashback_session_time", &self.flashback_session_time());
      ds.finish()
  }
}
pub enum ButtonsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Buttons<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Buttons<'a> {
  type Inner = Buttons<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Buttons<'a> {
  pub const VT_BUTTON_STATUS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Buttons { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ButtonsArgs
  ) -> flatbuffers::WIPOffset<Buttons<'bldr>> {
    let mut builder = ButtonsBuilder::new(_fbb);
    builder.add_button_status(args.button_status);
    builder.finish()
  }


  #[inline]
  pub fn button_status(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Buttons::VT_BUTTON_STATUS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Buttons<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("button_status", Self::VT_BUTTON_STATUS, false)?
     .finish();
    Ok(())
  }
}
pub struct ButtonsArgs {
    pub button_status: u32,
}
impl<'a> Default for ButtonsArgs {
  #[inline]
  fn default() -> Self {
    ButtonsArgs {
      button_status: 0,
    }
  }
}

pub struct ButtonsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ButtonsBuilder<'a, 'b> {
  #[inline]
  pub fn add_button_status(&mut self, button_status: u32) {
    self.fbb_.push_slot::<u32>(Buttons::VT_BUTTON_STATUS, button_status, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ButtonsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ButtonsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Buttons<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Buttons<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Buttons");
      ds.field("button_status", &self.button_status());
      ds.finish()
  }
}
pub enum OvertakeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Overtake<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Overtake<'a> {
  type Inner = Overtake<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Overtake<'a> {
  pub const VT_OVERTAKING_VEHICLE_IDX: flatbuffers::VOffsetT = 4;
  pub const VT_BEING_OVERTAKEN_VEHICLE_IDX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Overtake { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OvertakeArgs
  ) -> flatbuffers::WIPOffset<Overtake<'bldr>> {
    let mut builder = OvertakeBuilder::new(_fbb);
    builder.add_being_overtaken_vehicle_idx(args.being_overtaken_vehicle_idx);
    builder.add_overtaking_vehicle_idx(args.overtaking_vehicle_idx);
    builder.finish()
  }


  #[inline]
  pub fn overtaking_vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Overtake::VT_OVERTAKING_VEHICLE_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn being_overtaken_vehicle_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Overtake::VT_BEING_OVERTAKEN_VEHICLE_IDX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Overtake<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("overtaking_vehicle_idx", Self::VT_OVERTAKING_VEHICLE_IDX, false)?
     .visit_field::<u8>("being_overtaken_vehicle_idx", Self::VT_BEING_OVERTAKEN_VEHICLE_IDX, false)?
     .finish();
    Ok(())
  }
}
pub struct OvertakeArgs {
    pub overtaking_vehicle_idx: u8,
    pub being_overtaken_vehicle_idx: u8,
}
impl<'a> Default for OvertakeArgs {
  #[inline]
  fn default() -> Self {
    OvertakeArgs {
      overtaking_vehicle_idx: 0,
      being_overtaken_vehicle_idx: 0,
    }
  }
}

pub struct OvertakeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OvertakeBuilder<'a, 'b> {
  #[inline]
  pub fn add_overtaking_vehicle_idx(&mut self, overtaking_vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(Overtake::VT_OVERTAKING_VEHICLE_IDX, overtaking_vehicle_idx, 0);
  }
  #[inline]
  pub fn add_being_overtaken_vehicle_idx(&mut self, being_overtaken_vehicle_idx: u8) {
    self.fbb_.push_slot::<u8>(Overtake::VT_BEING_OVERTAKEN_VEHICLE_IDX, being_overtaken_vehicle_idx, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OvertakeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OvertakeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Overtake<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Overtake<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Overtake");
      ds.field("overtaking_vehicle_idx", &self.overtaking_vehicle_idx());
      ds.field("being_overtaken_vehicle_idx", &self.being_overtaken_vehicle_idx());
      ds.finish()
  }
}
pub enum event_data_detailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct event_data_details<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for event_data_details<'a> {
  type Inner = event_data_details<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> event_data_details<'a> {
  pub const VT_DETAILS_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DETAILS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    event_data_details { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args event_data_detailsArgs
  ) -> flatbuffers::WIPOffset<event_data_details<'bldr>> {
    let mut builder = event_data_detailsBuilder::new(_fbb);
    if let Some(x) = args.details { builder.add_details(x); }
    builder.add_details_type(args.details_type);
    builder.finish()
  }


  #[inline]
  pub fn details_type(&self) -> EventDataDetailsUnion {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EventDataDetailsUnion>(event_data_details::VT_DETAILS_TYPE, Some(EventDataDetailsUnion::NONE)).unwrap()}
  }
  #[inline]
  pub fn details(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(event_data_details::VT_DETAILS, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_fastest_lap(&self) -> Option<FastestLap<'a>> {
    if self.details_type() == EventDataDetailsUnion::FastestLap {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { FastestLap::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_retirement(&self) -> Option<Retirement<'a>> {
    if self.details_type() == EventDataDetailsUnion::Retirement {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Retirement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_team_mate_in_pits(&self) -> Option<TeamMateInPits<'a>> {
    if self.details_type() == EventDataDetailsUnion::TeamMateInPits {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { TeamMateInPits::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_race_winner(&self) -> Option<RaceWinner<'a>> {
    if self.details_type() == EventDataDetailsUnion::RaceWinner {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RaceWinner::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_penalty(&self) -> Option<Penalty<'a>> {
    if self.details_type() == EventDataDetailsUnion::Penalty {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Penalty::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_speed_trap(&self) -> Option<SpeedTrap<'a>> {
    if self.details_type() == EventDataDetailsUnion::SpeedTrap {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SpeedTrap::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_start_lights(&self) -> Option<StartLights<'a>> {
    if self.details_type() == EventDataDetailsUnion::StartLights {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StartLights::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_drive_through_penalty_served(&self) -> Option<DriveThroughPenaltyServed<'a>> {
    if self.details_type() == EventDataDetailsUnion::DriveThroughPenaltyServed {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DriveThroughPenaltyServed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_stop_go_penalty_served(&self) -> Option<StopGoPenaltyServed<'a>> {
    if self.details_type() == EventDataDetailsUnion::StopGoPenaltyServed {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StopGoPenaltyServed::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_flashback(&self) -> Option<Flashback<'a>> {
    if self.details_type() == EventDataDetailsUnion::Flashback {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Flashback::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_buttons(&self) -> Option<Buttons<'a>> {
    if self.details_type() == EventDataDetailsUnion::Buttons {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Buttons::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_overtake(&self) -> Option<Overtake<'a>> {
    if self.details_type() == EventDataDetailsUnion::Overtake {
      self.details().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Overtake::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for event_data_details<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<EventDataDetailsUnion, _>("details_type", Self::VT_DETAILS_TYPE, "details", Self::VT_DETAILS, false, |key, v, pos| {
        match key {
          EventDataDetailsUnion::FastestLap => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FastestLap>>("EventDataDetailsUnion::FastestLap", pos),
          EventDataDetailsUnion::Retirement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Retirement>>("EventDataDetailsUnion::Retirement", pos),
          EventDataDetailsUnion::TeamMateInPits => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TeamMateInPits>>("EventDataDetailsUnion::TeamMateInPits", pos),
          EventDataDetailsUnion::RaceWinner => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RaceWinner>>("EventDataDetailsUnion::RaceWinner", pos),
          EventDataDetailsUnion::Penalty => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Penalty>>("EventDataDetailsUnion::Penalty", pos),
          EventDataDetailsUnion::SpeedTrap => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpeedTrap>>("EventDataDetailsUnion::SpeedTrap", pos),
          EventDataDetailsUnion::StartLights => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StartLights>>("EventDataDetailsUnion::StartLights", pos),
          EventDataDetailsUnion::DriveThroughPenaltyServed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DriveThroughPenaltyServed>>("EventDataDetailsUnion::DriveThroughPenaltyServed", pos),
          EventDataDetailsUnion::StopGoPenaltyServed => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StopGoPenaltyServed>>("EventDataDetailsUnion::StopGoPenaltyServed", pos),
          EventDataDetailsUnion::Flashback => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Flashback>>("EventDataDetailsUnion::Flashback", pos),
          EventDataDetailsUnion::Buttons => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Buttons>>("EventDataDetailsUnion::Buttons", pos),
          EventDataDetailsUnion::Overtake => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Overtake>>("EventDataDetailsUnion::Overtake", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct event_data_detailsArgs {
    pub details_type: EventDataDetailsUnion,
    pub details: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for event_data_detailsArgs {
  #[inline]
  fn default() -> Self {
    event_data_detailsArgs {
      details_type: EventDataDetailsUnion::NONE,
      details: None,
    }
  }
}

pub struct event_data_detailsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> event_data_detailsBuilder<'a, 'b> {
  #[inline]
  pub fn add_details_type(&mut self, details_type: EventDataDetailsUnion) {
    self.fbb_.push_slot::<EventDataDetailsUnion>(event_data_details::VT_DETAILS_TYPE, details_type, EventDataDetailsUnion::NONE);
  }
  #[inline]
  pub fn add_details(&mut self, details: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(event_data_details::VT_DETAILS, details);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> event_data_detailsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    event_data_detailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<event_data_details<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for event_data_details<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("event_data_details");
      ds.field("details_type", &self.details_type());
      match self.details_type() {
        EventDataDetailsUnion::FastestLap => {
          if let Some(x) = self.details_as_fastest_lap() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::Retirement => {
          if let Some(x) = self.details_as_retirement() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::TeamMateInPits => {
          if let Some(x) = self.details_as_team_mate_in_pits() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::RaceWinner => {
          if let Some(x) = self.details_as_race_winner() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::Penalty => {
          if let Some(x) = self.details_as_penalty() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::SpeedTrap => {
          if let Some(x) = self.details_as_speed_trap() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::StartLights => {
          if let Some(x) = self.details_as_start_lights() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::DriveThroughPenaltyServed => {
          if let Some(x) = self.details_as_drive_through_penalty_served() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::StopGoPenaltyServed => {
          if let Some(x) = self.details_as_stop_go_penalty_served() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::Flashback => {
          if let Some(x) = self.details_as_flashback() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::Buttons => {
          if let Some(x) = self.details_as_buttons() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        EventDataDetailsUnion::Overtake => {
          if let Some(x) = self.details_as_overtake() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("details", &x)
        },
      };
      ds.finish()
  }
}
pub enum PacketEventDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PacketEventData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PacketEventData<'a> {
  type Inner = PacketEventData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PacketEventData<'a> {
  pub const VT_M_EVENT_STRING_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_M_EVENT_DETAILS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PacketEventData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketEventDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PacketEventData<'bldr>> {
    let mut builder = PacketEventDataBuilder::new(_fbb);
    if let Some(x) = args.m_event_details { builder.add_m_event_details(x); }
    if let Some(x) = args.m_event_string_code { builder.add_m_event_string_code(x); }
    builder.finish()
  }


  #[inline]
  pub fn m_event_string_code(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(PacketEventData::VT_M_EVENT_STRING_CODE, None)}
  }
  #[inline]
  pub fn m_event_details(&self) -> Option<event_data_details<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<event_data_details>>(PacketEventData::VT_M_EVENT_DETAILS, None)}
  }
}

impl flatbuffers::Verifiable for PacketEventData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("m_event_string_code", Self::VT_M_EVENT_STRING_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<event_data_details>>("m_event_details", Self::VT_M_EVENT_DETAILS, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketEventDataArgs<'a> {
    pub m_event_string_code: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub m_event_details: Option<flatbuffers::WIPOffset<event_data_details<'a>>>,
}
impl<'a> Default for PacketEventDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketEventDataArgs {
      m_event_string_code: None,
      m_event_details: None,
    }
  }
}

pub struct PacketEventDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketEventDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_event_string_code(&mut self, m_event_string_code: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketEventData::VT_M_EVENT_STRING_CODE, m_event_string_code);
  }
  #[inline]
  pub fn add_m_event_details(&mut self, m_event_details: flatbuffers::WIPOffset<event_data_details<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<event_data_details>>(PacketEventData::VT_M_EVENT_DETAILS, m_event_details);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketEventDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketEventDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PacketEventData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PacketEventData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PacketEventData");
      ds.field("m_event_string_code", &self.m_event_string_code());
      ds.field("m_event_details", &self.m_event_details());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PacketEventData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_event_data_unchecked`.
pub fn root_as_packet_event_data(buf: &[u8]) -> Result<PacketEventData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PacketEventData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PacketEventData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_packet_event_data_unchecked`.
pub fn size_prefixed_root_as_packet_event_data(buf: &[u8]) -> Result<PacketEventData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PacketEventData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PacketEventData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_event_data_unchecked`.
pub fn root_as_packet_event_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketEventData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PacketEventData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PacketEventData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_event_data_unchecked`.
pub fn size_prefixed_root_as_packet_event_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketEventData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PacketEventData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PacketEventData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PacketEventData`.
pub unsafe fn root_as_packet_event_data_unchecked(buf: &[u8]) -> PacketEventData {
  flatbuffers::root_unchecked::<PacketEventData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PacketEventData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PacketEventData`.
pub unsafe fn size_prefixed_root_as_packet_event_data_unchecked(buf: &[u8]) -> PacketEventData {
  flatbuffers::size_prefixed_root_unchecked::<PacketEventData>(buf)
}
#[inline]
pub fn finish_packet_event_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PacketEventData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_event_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<PacketEventData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod event_data
}  // pub mod protos

