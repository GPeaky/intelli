// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protos {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod session_history {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum LapHistoryDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LapHistoryData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LapHistoryData<'a> {
  type Inner = LapHistoryData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LapHistoryData<'a> {
  pub const VT_M_LAP_TIME_IN_MS: flatbuffers::VOffsetT = 4;
  pub const VT_M_SECTOR1_TIME_IN_MS: flatbuffers::VOffsetT = 6;
  pub const VT_M_SECTOR1_TIME_MINUTES: flatbuffers::VOffsetT = 8;
  pub const VT_M_SECTOR2_TIME_IN_MS: flatbuffers::VOffsetT = 10;
  pub const VT_M_SECTOR2_TIME_MINUTES: flatbuffers::VOffsetT = 12;
  pub const VT_M_SECTOR3_TIME_IN_MS: flatbuffers::VOffsetT = 14;
  pub const VT_M_SECTOR3_TIME_MINUTES: flatbuffers::VOffsetT = 16;
  pub const VT_M_LAP_VALID_BIT_FLAGS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LapHistoryData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LapHistoryDataArgs
  ) -> flatbuffers::WIPOffset<LapHistoryData<'bldr>> {
    let mut builder = LapHistoryDataBuilder::new(_fbb);
    builder.add_m_lap_time_in_ms(args.m_lap_time_in_ms);
    builder.add_m_sector3_time_in_ms(args.m_sector3_time_in_ms);
    builder.add_m_sector2_time_in_ms(args.m_sector2_time_in_ms);
    builder.add_m_sector1_time_in_ms(args.m_sector1_time_in_ms);
    builder.add_m_lap_valid_bit_flags(args.m_lap_valid_bit_flags);
    builder.add_m_sector3_time_minutes(args.m_sector3_time_minutes);
    builder.add_m_sector2_time_minutes(args.m_sector2_time_minutes);
    builder.add_m_sector1_time_minutes(args.m_sector1_time_minutes);
    builder.finish()
  }


  #[inline]
  pub fn m_lap_time_in_ms(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(LapHistoryData::VT_M_LAP_TIME_IN_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector1_time_in_ms(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(LapHistoryData::VT_M_SECTOR1_TIME_IN_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector1_time_minutes(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LapHistoryData::VT_M_SECTOR1_TIME_MINUTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector2_time_in_ms(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(LapHistoryData::VT_M_SECTOR2_TIME_IN_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector2_time_minutes(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LapHistoryData::VT_M_SECTOR2_TIME_MINUTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector3_time_in_ms(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(LapHistoryData::VT_M_SECTOR3_TIME_IN_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sector3_time_minutes(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LapHistoryData::VT_M_SECTOR3_TIME_MINUTES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_lap_valid_bit_flags(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(LapHistoryData::VT_M_LAP_VALID_BIT_FLAGS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LapHistoryData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("m_lap_time_in_ms", Self::VT_M_LAP_TIME_IN_MS, false)?
     .visit_field::<u16>("m_sector1_time_in_ms", Self::VT_M_SECTOR1_TIME_IN_MS, false)?
     .visit_field::<u8>("m_sector1_time_minutes", Self::VT_M_SECTOR1_TIME_MINUTES, false)?
     .visit_field::<u16>("m_sector2_time_in_ms", Self::VT_M_SECTOR2_TIME_IN_MS, false)?
     .visit_field::<u8>("m_sector2_time_minutes", Self::VT_M_SECTOR2_TIME_MINUTES, false)?
     .visit_field::<u16>("m_sector3_time_in_ms", Self::VT_M_SECTOR3_TIME_IN_MS, false)?
     .visit_field::<u8>("m_sector3_time_minutes", Self::VT_M_SECTOR3_TIME_MINUTES, false)?
     .visit_field::<u8>("m_lap_valid_bit_flags", Self::VT_M_LAP_VALID_BIT_FLAGS, false)?
     .finish();
    Ok(())
  }
}
pub struct LapHistoryDataArgs {
    pub m_lap_time_in_ms: u32,
    pub m_sector1_time_in_ms: u16,
    pub m_sector1_time_minutes: u8,
    pub m_sector2_time_in_ms: u16,
    pub m_sector2_time_minutes: u8,
    pub m_sector3_time_in_ms: u16,
    pub m_sector3_time_minutes: u8,
    pub m_lap_valid_bit_flags: u8,
}
impl<'a> Default for LapHistoryDataArgs {
  #[inline]
  fn default() -> Self {
    LapHistoryDataArgs {
      m_lap_time_in_ms: 0,
      m_sector1_time_in_ms: 0,
      m_sector1_time_minutes: 0,
      m_sector2_time_in_ms: 0,
      m_sector2_time_minutes: 0,
      m_sector3_time_in_ms: 0,
      m_sector3_time_minutes: 0,
      m_lap_valid_bit_flags: 0,
    }
  }
}

pub struct LapHistoryDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LapHistoryDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_lap_time_in_ms(&mut self, m_lap_time_in_ms: u32) {
    self.fbb_.push_slot::<u32>(LapHistoryData::VT_M_LAP_TIME_IN_MS, m_lap_time_in_ms, 0);
  }
  #[inline]
  pub fn add_m_sector1_time_in_ms(&mut self, m_sector1_time_in_ms: u16) {
    self.fbb_.push_slot::<u16>(LapHistoryData::VT_M_SECTOR1_TIME_IN_MS, m_sector1_time_in_ms, 0);
  }
  #[inline]
  pub fn add_m_sector1_time_minutes(&mut self, m_sector1_time_minutes: u8) {
    self.fbb_.push_slot::<u8>(LapHistoryData::VT_M_SECTOR1_TIME_MINUTES, m_sector1_time_minutes, 0);
  }
  #[inline]
  pub fn add_m_sector2_time_in_ms(&mut self, m_sector2_time_in_ms: u16) {
    self.fbb_.push_slot::<u16>(LapHistoryData::VT_M_SECTOR2_TIME_IN_MS, m_sector2_time_in_ms, 0);
  }
  #[inline]
  pub fn add_m_sector2_time_minutes(&mut self, m_sector2_time_minutes: u8) {
    self.fbb_.push_slot::<u8>(LapHistoryData::VT_M_SECTOR2_TIME_MINUTES, m_sector2_time_minutes, 0);
  }
  #[inline]
  pub fn add_m_sector3_time_in_ms(&mut self, m_sector3_time_in_ms: u16) {
    self.fbb_.push_slot::<u16>(LapHistoryData::VT_M_SECTOR3_TIME_IN_MS, m_sector3_time_in_ms, 0);
  }
  #[inline]
  pub fn add_m_sector3_time_minutes(&mut self, m_sector3_time_minutes: u8) {
    self.fbb_.push_slot::<u8>(LapHistoryData::VT_M_SECTOR3_TIME_MINUTES, m_sector3_time_minutes, 0);
  }
  #[inline]
  pub fn add_m_lap_valid_bit_flags(&mut self, m_lap_valid_bit_flags: u8) {
    self.fbb_.push_slot::<u8>(LapHistoryData::VT_M_LAP_VALID_BIT_FLAGS, m_lap_valid_bit_flags, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LapHistoryDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LapHistoryDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LapHistoryData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LapHistoryData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LapHistoryData");
      ds.field("m_lap_time_in_ms", &self.m_lap_time_in_ms());
      ds.field("m_sector1_time_in_ms", &self.m_sector1_time_in_ms());
      ds.field("m_sector1_time_minutes", &self.m_sector1_time_minutes());
      ds.field("m_sector2_time_in_ms", &self.m_sector2_time_in_ms());
      ds.field("m_sector2_time_minutes", &self.m_sector2_time_minutes());
      ds.field("m_sector3_time_in_ms", &self.m_sector3_time_in_ms());
      ds.field("m_sector3_time_minutes", &self.m_sector3_time_minutes());
      ds.field("m_lap_valid_bit_flags", &self.m_lap_valid_bit_flags());
      ds.finish()
  }
}
pub enum TyreStintHistoryDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TyreStintHistoryData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TyreStintHistoryData<'a> {
  type Inner = TyreStintHistoryData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TyreStintHistoryData<'a> {
  pub const VT_M_END_LAP: flatbuffers::VOffsetT = 4;
  pub const VT_M_TYRE_ACTUAL_COMPOUND: flatbuffers::VOffsetT = 6;
  pub const VT_M_TYRE_VISUAL_COMPOUND: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TyreStintHistoryData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TyreStintHistoryDataArgs
  ) -> flatbuffers::WIPOffset<TyreStintHistoryData<'bldr>> {
    let mut builder = TyreStintHistoryDataBuilder::new(_fbb);
    builder.add_m_tyre_visual_compound(args.m_tyre_visual_compound);
    builder.add_m_tyre_actual_compound(args.m_tyre_actual_compound);
    builder.add_m_end_lap(args.m_end_lap);
    builder.finish()
  }


  #[inline]
  pub fn m_end_lap(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TyreStintHistoryData::VT_M_END_LAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_tyre_actual_compound(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TyreStintHistoryData::VT_M_TYRE_ACTUAL_COMPOUND, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_tyre_visual_compound(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(TyreStintHistoryData::VT_M_TYRE_VISUAL_COMPOUND, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TyreStintHistoryData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_end_lap", Self::VT_M_END_LAP, false)?
     .visit_field::<u8>("m_tyre_actual_compound", Self::VT_M_TYRE_ACTUAL_COMPOUND, false)?
     .visit_field::<u8>("m_tyre_visual_compound", Self::VT_M_TYRE_VISUAL_COMPOUND, false)?
     .finish();
    Ok(())
  }
}
pub struct TyreStintHistoryDataArgs {
    pub m_end_lap: u8,
    pub m_tyre_actual_compound: u8,
    pub m_tyre_visual_compound: u8,
}
impl<'a> Default for TyreStintHistoryDataArgs {
  #[inline]
  fn default() -> Self {
    TyreStintHistoryDataArgs {
      m_end_lap: 0,
      m_tyre_actual_compound: 0,
      m_tyre_visual_compound: 0,
    }
  }
}

pub struct TyreStintHistoryDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TyreStintHistoryDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_end_lap(&mut self, m_end_lap: u8) {
    self.fbb_.push_slot::<u8>(TyreStintHistoryData::VT_M_END_LAP, m_end_lap, 0);
  }
  #[inline]
  pub fn add_m_tyre_actual_compound(&mut self, m_tyre_actual_compound: u8) {
    self.fbb_.push_slot::<u8>(TyreStintHistoryData::VT_M_TYRE_ACTUAL_COMPOUND, m_tyre_actual_compound, 0);
  }
  #[inline]
  pub fn add_m_tyre_visual_compound(&mut self, m_tyre_visual_compound: u8) {
    self.fbb_.push_slot::<u8>(TyreStintHistoryData::VT_M_TYRE_VISUAL_COMPOUND, m_tyre_visual_compound, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TyreStintHistoryDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TyreStintHistoryDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TyreStintHistoryData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TyreStintHistoryData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TyreStintHistoryData");
      ds.field("m_end_lap", &self.m_end_lap());
      ds.field("m_tyre_actual_compound", &self.m_tyre_actual_compound());
      ds.field("m_tyre_visual_compound", &self.m_tyre_visual_compound());
      ds.finish()
  }
}
pub enum PacketSessionHistoryDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PacketSessionHistoryData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PacketSessionHistoryData<'a> {
  type Inner = PacketSessionHistoryData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PacketSessionHistoryData<'a> {
  pub const VT_M_CAR_IDX: flatbuffers::VOffsetT = 4;
  pub const VT_M_NUM_LAPS: flatbuffers::VOffsetT = 6;
  pub const VT_M_NUM_TYRE_STINTS: flatbuffers::VOffsetT = 8;
  pub const VT_M_BEST_LAP_TIME_LAP_NUM: flatbuffers::VOffsetT = 10;
  pub const VT_M_BEST_SECTOR1_LAP_NUM: flatbuffers::VOffsetT = 12;
  pub const VT_M_BEST_SECTOR2_LAP_NUM: flatbuffers::VOffsetT = 14;
  pub const VT_M_BEST_SECTOR3_LAP_NUM: flatbuffers::VOffsetT = 16;
  pub const VT_M_LAP_HISTORY_DATA: flatbuffers::VOffsetT = 18;
  pub const VT_M_TYRE_STINTS_HISTORY_DATA: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PacketSessionHistoryData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketSessionHistoryDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PacketSessionHistoryData<'bldr>> {
    let mut builder = PacketSessionHistoryDataBuilder::new(_fbb);
    if let Some(x) = args.m_tyre_stints_history_data { builder.add_m_tyre_stints_history_data(x); }
    if let Some(x) = args.m_lap_history_data { builder.add_m_lap_history_data(x); }
    builder.add_m_best_sector3_lap_num(args.m_best_sector3_lap_num);
    builder.add_m_best_sector2_lap_num(args.m_best_sector2_lap_num);
    builder.add_m_best_sector1_lap_num(args.m_best_sector1_lap_num);
    builder.add_m_best_lap_time_lap_num(args.m_best_lap_time_lap_num);
    builder.add_m_num_tyre_stints(args.m_num_tyre_stints);
    builder.add_m_num_laps(args.m_num_laps);
    builder.add_m_car_idx(args.m_car_idx);
    builder.finish()
  }


  #[inline]
  pub fn m_car_idx(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_CAR_IDX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_laps(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_NUM_LAPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_tyre_stints(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_NUM_TYRE_STINTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_best_lap_time_lap_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_BEST_LAP_TIME_LAP_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_best_sector1_lap_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR1_LAP_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_best_sector2_lap_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR2_LAP_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_best_sector3_lap_num(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR3_LAP_NUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_lap_history_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LapHistoryData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LapHistoryData>>>>(PacketSessionHistoryData::VT_M_LAP_HISTORY_DATA, None)}
  }
  #[inline]
  pub fn m_tyre_stints_history_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TyreStintHistoryData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TyreStintHistoryData>>>>(PacketSessionHistoryData::VT_M_TYRE_STINTS_HISTORY_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PacketSessionHistoryData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_car_idx", Self::VT_M_CAR_IDX, false)?
     .visit_field::<u8>("m_num_laps", Self::VT_M_NUM_LAPS, false)?
     .visit_field::<u8>("m_num_tyre_stints", Self::VT_M_NUM_TYRE_STINTS, false)?
     .visit_field::<u8>("m_best_lap_time_lap_num", Self::VT_M_BEST_LAP_TIME_LAP_NUM, false)?
     .visit_field::<u8>("m_best_sector1_lap_num", Self::VT_M_BEST_SECTOR1_LAP_NUM, false)?
     .visit_field::<u8>("m_best_sector2_lap_num", Self::VT_M_BEST_SECTOR2_LAP_NUM, false)?
     .visit_field::<u8>("m_best_sector3_lap_num", Self::VT_M_BEST_SECTOR3_LAP_NUM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<LapHistoryData>>>>("m_lap_history_data", Self::VT_M_LAP_HISTORY_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TyreStintHistoryData>>>>("m_tyre_stints_history_data", Self::VT_M_TYRE_STINTS_HISTORY_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketSessionHistoryDataArgs<'a> {
    pub m_car_idx: u8,
    pub m_num_laps: u8,
    pub m_num_tyre_stints: u8,
    pub m_best_lap_time_lap_num: u8,
    pub m_best_sector1_lap_num: u8,
    pub m_best_sector2_lap_num: u8,
    pub m_best_sector3_lap_num: u8,
    pub m_lap_history_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<LapHistoryData<'a>>>>>,
    pub m_tyre_stints_history_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TyreStintHistoryData<'a>>>>>,
}
impl<'a> Default for PacketSessionHistoryDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketSessionHistoryDataArgs {
      m_car_idx: 0,
      m_num_laps: 0,
      m_num_tyre_stints: 0,
      m_best_lap_time_lap_num: 0,
      m_best_sector1_lap_num: 0,
      m_best_sector2_lap_num: 0,
      m_best_sector3_lap_num: 0,
      m_lap_history_data: None,
      m_tyre_stints_history_data: None,
    }
  }
}

pub struct PacketSessionHistoryDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketSessionHistoryDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_car_idx(&mut self, m_car_idx: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_CAR_IDX, m_car_idx, 0);
  }
  #[inline]
  pub fn add_m_num_laps(&mut self, m_num_laps: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_NUM_LAPS, m_num_laps, 0);
  }
  #[inline]
  pub fn add_m_num_tyre_stints(&mut self, m_num_tyre_stints: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_NUM_TYRE_STINTS, m_num_tyre_stints, 0);
  }
  #[inline]
  pub fn add_m_best_lap_time_lap_num(&mut self, m_best_lap_time_lap_num: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_BEST_LAP_TIME_LAP_NUM, m_best_lap_time_lap_num, 0);
  }
  #[inline]
  pub fn add_m_best_sector1_lap_num(&mut self, m_best_sector1_lap_num: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR1_LAP_NUM, m_best_sector1_lap_num, 0);
  }
  #[inline]
  pub fn add_m_best_sector2_lap_num(&mut self, m_best_sector2_lap_num: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR2_LAP_NUM, m_best_sector2_lap_num, 0);
  }
  #[inline]
  pub fn add_m_best_sector3_lap_num(&mut self, m_best_sector3_lap_num: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionHistoryData::VT_M_BEST_SECTOR3_LAP_NUM, m_best_sector3_lap_num, 0);
  }
  #[inline]
  pub fn add_m_lap_history_data(&mut self, m_lap_history_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<LapHistoryData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketSessionHistoryData::VT_M_LAP_HISTORY_DATA, m_lap_history_data);
  }
  #[inline]
  pub fn add_m_tyre_stints_history_data(&mut self, m_tyre_stints_history_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TyreStintHistoryData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketSessionHistoryData::VT_M_TYRE_STINTS_HISTORY_DATA, m_tyre_stints_history_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketSessionHistoryDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketSessionHistoryDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PacketSessionHistoryData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PacketSessionHistoryData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PacketSessionHistoryData");
      ds.field("m_car_idx", &self.m_car_idx());
      ds.field("m_num_laps", &self.m_num_laps());
      ds.field("m_num_tyre_stints", &self.m_num_tyre_stints());
      ds.field("m_best_lap_time_lap_num", &self.m_best_lap_time_lap_num());
      ds.field("m_best_sector1_lap_num", &self.m_best_sector1_lap_num());
      ds.field("m_best_sector2_lap_num", &self.m_best_sector2_lap_num());
      ds.field("m_best_sector3_lap_num", &self.m_best_sector3_lap_num());
      ds.field("m_lap_history_data", &self.m_lap_history_data());
      ds.field("m_tyre_stints_history_data", &self.m_tyre_stints_history_data());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PacketSessionHistoryData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_history_data_unchecked`.
pub fn root_as_packet_session_history_data(buf: &[u8]) -> Result<PacketSessionHistoryData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PacketSessionHistoryData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PacketSessionHistoryData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_packet_session_history_data_unchecked`.
pub fn size_prefixed_root_as_packet_session_history_data(buf: &[u8]) -> Result<PacketSessionHistoryData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PacketSessionHistoryData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PacketSessionHistoryData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_history_data_unchecked`.
pub fn root_as_packet_session_history_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketSessionHistoryData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PacketSessionHistoryData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PacketSessionHistoryData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_history_data_unchecked`.
pub fn size_prefixed_root_as_packet_session_history_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketSessionHistoryData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PacketSessionHistoryData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PacketSessionHistoryData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PacketSessionHistoryData`.
pub unsafe fn root_as_packet_session_history_data_unchecked(buf: &[u8]) -> PacketSessionHistoryData {
  flatbuffers::root_unchecked::<PacketSessionHistoryData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PacketSessionHistoryData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PacketSessionHistoryData`.
pub unsafe fn size_prefixed_root_as_packet_session_history_data_unchecked(buf: &[u8]) -> PacketSessionHistoryData {
  flatbuffers::size_prefixed_root_unchecked::<PacketSessionHistoryData>(buf)
}
#[inline]
pub fn finish_packet_session_history_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PacketSessionHistoryData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_session_history_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<PacketSessionHistoryData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod session_history
}  // pub mod protos

