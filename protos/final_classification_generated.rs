// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protos {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod final_classification {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum FinalClassificationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FinalClassificationData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FinalClassificationData<'a> {
  type Inner = FinalClassificationData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FinalClassificationData<'a> {
  pub const VT_M_POSITION: flatbuffers::VOffsetT = 4;
  pub const VT_M_NUM_LAPS: flatbuffers::VOffsetT = 6;
  pub const VT_M_GRID_POSITION: flatbuffers::VOffsetT = 8;
  pub const VT_M_POINTS: flatbuffers::VOffsetT = 10;
  pub const VT_M_NUM_PIT_STOPS: flatbuffers::VOffsetT = 12;
  pub const VT_M_RESULT_STATUS: flatbuffers::VOffsetT = 14;
  pub const VT_M_BEST_LAP_TIME_IN_MS: flatbuffers::VOffsetT = 16;
  pub const VT_M_TOTAL_RACE_TIME: flatbuffers::VOffsetT = 18;
  pub const VT_M_PENALTIES_TIME: flatbuffers::VOffsetT = 20;
  pub const VT_M_NUM_PENALTIES: flatbuffers::VOffsetT = 22;
  pub const VT_M_NUM_TYRE_STINTS: flatbuffers::VOffsetT = 24;
  pub const VT_M_TYRE_STINTS_ACTUAL: flatbuffers::VOffsetT = 26;
  pub const VT_M_TYRE_STINTS_VISUAL: flatbuffers::VOffsetT = 28;
  pub const VT_M_TYRE_STINTS_END_LAPS: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FinalClassificationData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FinalClassificationDataArgs<'args>
  ) -> flatbuffers::WIPOffset<FinalClassificationData<'bldr>> {
    let mut builder = FinalClassificationDataBuilder::new(_fbb);
    builder.add_m_total_race_time(args.m_total_race_time);
    if let Some(x) = args.m_tyre_stints_end_laps { builder.add_m_tyre_stints_end_laps(x); }
    if let Some(x) = args.m_tyre_stints_visual { builder.add_m_tyre_stints_visual(x); }
    if let Some(x) = args.m_tyre_stints_actual { builder.add_m_tyre_stints_actual(x); }
    builder.add_m_best_lap_time_in_ms(args.m_best_lap_time_in_ms);
    builder.add_m_num_tyre_stints(args.m_num_tyre_stints);
    builder.add_m_num_penalties(args.m_num_penalties);
    builder.add_m_penalties_time(args.m_penalties_time);
    builder.add_m_result_status(args.m_result_status);
    builder.add_m_num_pit_stops(args.m_num_pit_stops);
    builder.add_m_points(args.m_points);
    builder.add_m_grid_position(args.m_grid_position);
    builder.add_m_num_laps(args.m_num_laps);
    builder.add_m_position(args.m_position);
    builder.finish()
  }


  #[inline]
  pub fn m_position(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_laps(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_NUM_LAPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_grid_position(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_GRID_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_points(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_POINTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_pit_stops(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_NUM_PIT_STOPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_result_status(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_RESULT_STATUS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_best_lap_time_in_ms(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(FinalClassificationData::VT_M_BEST_LAP_TIME_IN_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_total_race_time(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FinalClassificationData::VT_M_TOTAL_RACE_TIME, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_penalties_time(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_PENALTIES_TIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_penalties(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_NUM_PENALTIES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_tyre_stints(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(FinalClassificationData::VT_M_NUM_TYRE_STINTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_tyre_stints_actual(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FinalClassificationData::VT_M_TYRE_STINTS_ACTUAL, None)}
  }
  #[inline]
  pub fn m_tyre_stints_visual(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FinalClassificationData::VT_M_TYRE_STINTS_VISUAL, None)}
  }
  #[inline]
  pub fn m_tyre_stints_end_laps(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(FinalClassificationData::VT_M_TYRE_STINTS_END_LAPS, None)}
  }
}

impl flatbuffers::Verifiable for FinalClassificationData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_position", Self::VT_M_POSITION, false)?
     .visit_field::<u8>("m_num_laps", Self::VT_M_NUM_LAPS, false)?
     .visit_field::<u8>("m_grid_position", Self::VT_M_GRID_POSITION, false)?
     .visit_field::<u8>("m_points", Self::VT_M_POINTS, false)?
     .visit_field::<u8>("m_num_pit_stops", Self::VT_M_NUM_PIT_STOPS, false)?
     .visit_field::<u8>("m_result_status", Self::VT_M_RESULT_STATUS, false)?
     .visit_field::<u32>("m_best_lap_time_in_ms", Self::VT_M_BEST_LAP_TIME_IN_MS, false)?
     .visit_field::<f64>("m_total_race_time", Self::VT_M_TOTAL_RACE_TIME, false)?
     .visit_field::<u8>("m_penalties_time", Self::VT_M_PENALTIES_TIME, false)?
     .visit_field::<u8>("m_num_penalties", Self::VT_M_NUM_PENALTIES, false)?
     .visit_field::<u8>("m_num_tyre_stints", Self::VT_M_NUM_TYRE_STINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("m_tyre_stints_actual", Self::VT_M_TYRE_STINTS_ACTUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("m_tyre_stints_visual", Self::VT_M_TYRE_STINTS_VISUAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("m_tyre_stints_end_laps", Self::VT_M_TYRE_STINTS_END_LAPS, false)?
     .finish();
    Ok(())
  }
}
pub struct FinalClassificationDataArgs<'a> {
    pub m_position: u8,
    pub m_num_laps: u8,
    pub m_grid_position: u8,
    pub m_points: u8,
    pub m_num_pit_stops: u8,
    pub m_result_status: u8,
    pub m_best_lap_time_in_ms: u32,
    pub m_total_race_time: f64,
    pub m_penalties_time: u8,
    pub m_num_penalties: u8,
    pub m_num_tyre_stints: u8,
    pub m_tyre_stints_actual: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub m_tyre_stints_visual: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub m_tyre_stints_end_laps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for FinalClassificationDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    FinalClassificationDataArgs {
      m_position: 0,
      m_num_laps: 0,
      m_grid_position: 0,
      m_points: 0,
      m_num_pit_stops: 0,
      m_result_status: 0,
      m_best_lap_time_in_ms: 0,
      m_total_race_time: 0.0,
      m_penalties_time: 0,
      m_num_penalties: 0,
      m_num_tyre_stints: 0,
      m_tyre_stints_actual: None,
      m_tyre_stints_visual: None,
      m_tyre_stints_end_laps: None,
    }
  }
}

pub struct FinalClassificationDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FinalClassificationDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_position(&mut self, m_position: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_POSITION, m_position, 0);
  }
  #[inline]
  pub fn add_m_num_laps(&mut self, m_num_laps: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_NUM_LAPS, m_num_laps, 0);
  }
  #[inline]
  pub fn add_m_grid_position(&mut self, m_grid_position: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_GRID_POSITION, m_grid_position, 0);
  }
  #[inline]
  pub fn add_m_points(&mut self, m_points: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_POINTS, m_points, 0);
  }
  #[inline]
  pub fn add_m_num_pit_stops(&mut self, m_num_pit_stops: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_NUM_PIT_STOPS, m_num_pit_stops, 0);
  }
  #[inline]
  pub fn add_m_result_status(&mut self, m_result_status: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_RESULT_STATUS, m_result_status, 0);
  }
  #[inline]
  pub fn add_m_best_lap_time_in_ms(&mut self, m_best_lap_time_in_ms: u32) {
    self.fbb_.push_slot::<u32>(FinalClassificationData::VT_M_BEST_LAP_TIME_IN_MS, m_best_lap_time_in_ms, 0);
  }
  #[inline]
  pub fn add_m_total_race_time(&mut self, m_total_race_time: f64) {
    self.fbb_.push_slot::<f64>(FinalClassificationData::VT_M_TOTAL_RACE_TIME, m_total_race_time, 0.0);
  }
  #[inline]
  pub fn add_m_penalties_time(&mut self, m_penalties_time: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_PENALTIES_TIME, m_penalties_time, 0);
  }
  #[inline]
  pub fn add_m_num_penalties(&mut self, m_num_penalties: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_NUM_PENALTIES, m_num_penalties, 0);
  }
  #[inline]
  pub fn add_m_num_tyre_stints(&mut self, m_num_tyre_stints: u8) {
    self.fbb_.push_slot::<u8>(FinalClassificationData::VT_M_NUM_TYRE_STINTS, m_num_tyre_stints, 0);
  }
  #[inline]
  pub fn add_m_tyre_stints_actual(&mut self, m_tyre_stints_actual: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FinalClassificationData::VT_M_TYRE_STINTS_ACTUAL, m_tyre_stints_actual);
  }
  #[inline]
  pub fn add_m_tyre_stints_visual(&mut self, m_tyre_stints_visual: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FinalClassificationData::VT_M_TYRE_STINTS_VISUAL, m_tyre_stints_visual);
  }
  #[inline]
  pub fn add_m_tyre_stints_end_laps(&mut self, m_tyre_stints_end_laps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FinalClassificationData::VT_M_TYRE_STINTS_END_LAPS, m_tyre_stints_end_laps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FinalClassificationDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FinalClassificationDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FinalClassificationData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FinalClassificationData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FinalClassificationData");
      ds.field("m_position", &self.m_position());
      ds.field("m_num_laps", &self.m_num_laps());
      ds.field("m_grid_position", &self.m_grid_position());
      ds.field("m_points", &self.m_points());
      ds.field("m_num_pit_stops", &self.m_num_pit_stops());
      ds.field("m_result_status", &self.m_result_status());
      ds.field("m_best_lap_time_in_ms", &self.m_best_lap_time_in_ms());
      ds.field("m_total_race_time", &self.m_total_race_time());
      ds.field("m_penalties_time", &self.m_penalties_time());
      ds.field("m_num_penalties", &self.m_num_penalties());
      ds.field("m_num_tyre_stints", &self.m_num_tyre_stints());
      ds.field("m_tyre_stints_actual", &self.m_tyre_stints_actual());
      ds.field("m_tyre_stints_visual", &self.m_tyre_stints_visual());
      ds.field("m_tyre_stints_end_laps", &self.m_tyre_stints_end_laps());
      ds.finish()
  }
}
pub enum PacketFinalClassificationDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PacketFinalClassificationData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PacketFinalClassificationData<'a> {
  type Inner = PacketFinalClassificationData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PacketFinalClassificationData<'a> {
  pub const VT_M_NUM_CARS: flatbuffers::VOffsetT = 4;
  pub const VT_M_CLASSIFICATION_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PacketFinalClassificationData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketFinalClassificationDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PacketFinalClassificationData<'bldr>> {
    let mut builder = PacketFinalClassificationDataBuilder::new(_fbb);
    if let Some(x) = args.m_classification_data { builder.add_m_classification_data(x); }
    builder.add_m_num_cars(args.m_num_cars);
    builder.finish()
  }


  #[inline]
  pub fn m_num_cars(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketFinalClassificationData::VT_M_NUM_CARS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_classification_data(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FinalClassificationData<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FinalClassificationData>>>>(PacketFinalClassificationData::VT_M_CLASSIFICATION_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PacketFinalClassificationData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_num_cars", Self::VT_M_NUM_CARS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FinalClassificationData>>>>("m_classification_data", Self::VT_M_CLASSIFICATION_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketFinalClassificationDataArgs<'a> {
    pub m_num_cars: u8,
    pub m_classification_data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FinalClassificationData<'a>>>>>,
}
impl<'a> Default for PacketFinalClassificationDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketFinalClassificationDataArgs {
      m_num_cars: 0,
      m_classification_data: None,
    }
  }
}

pub struct PacketFinalClassificationDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketFinalClassificationDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_num_cars(&mut self, m_num_cars: u8) {
    self.fbb_.push_slot::<u8>(PacketFinalClassificationData::VT_M_NUM_CARS, m_num_cars, 0);
  }
  #[inline]
  pub fn add_m_classification_data(&mut self, m_classification_data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FinalClassificationData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketFinalClassificationData::VT_M_CLASSIFICATION_DATA, m_classification_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketFinalClassificationDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketFinalClassificationDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PacketFinalClassificationData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PacketFinalClassificationData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PacketFinalClassificationData");
      ds.field("m_num_cars", &self.m_num_cars());
      ds.field("m_classification_data", &self.m_classification_data());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PacketFinalClassificationData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_final_classification_data_unchecked`.
pub fn root_as_packet_final_classification_data(buf: &[u8]) -> Result<PacketFinalClassificationData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PacketFinalClassificationData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PacketFinalClassificationData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_packet_final_classification_data_unchecked`.
pub fn size_prefixed_root_as_packet_final_classification_data(buf: &[u8]) -> Result<PacketFinalClassificationData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PacketFinalClassificationData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PacketFinalClassificationData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_final_classification_data_unchecked`.
pub fn root_as_packet_final_classification_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketFinalClassificationData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PacketFinalClassificationData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PacketFinalClassificationData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_final_classification_data_unchecked`.
pub fn size_prefixed_root_as_packet_final_classification_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketFinalClassificationData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PacketFinalClassificationData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PacketFinalClassificationData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PacketFinalClassificationData`.
pub unsafe fn root_as_packet_final_classification_data_unchecked(buf: &[u8]) -> PacketFinalClassificationData {
  flatbuffers::root_unchecked::<PacketFinalClassificationData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PacketFinalClassificationData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PacketFinalClassificationData`.
pub unsafe fn size_prefixed_root_as_packet_final_classification_data_unchecked(buf: &[u8]) -> PacketFinalClassificationData {
  flatbuffers::size_prefixed_root_unchecked::<PacketFinalClassificationData>(buf)
}
#[inline]
pub fn finish_packet_final_classification_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PacketFinalClassificationData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_final_classification_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<PacketFinalClassificationData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod final_classification
}  // pub mod protos

