// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod protos {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod session_data {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MarshalZoneOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MarshalZone<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MarshalZone<'a> {
  type Inner = MarshalZone<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MarshalZone<'a> {
  pub const VT_M_ZONE_START: flatbuffers::VOffsetT = 4;
  pub const VT_M_ZONE_FLAG: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MarshalZone { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MarshalZoneArgs
  ) -> flatbuffers::WIPOffset<MarshalZone<'bldr>> {
    let mut builder = MarshalZoneBuilder::new(_fbb);
    builder.add_m_zone_start(args.m_zone_start);
    builder.add_m_zone_flag(args.m_zone_flag);
    builder.finish()
  }


  #[inline]
  pub fn m_zone_start(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MarshalZone::VT_M_ZONE_START, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn m_zone_flag(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(MarshalZone::VT_M_ZONE_FLAG, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MarshalZone<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("m_zone_start", Self::VT_M_ZONE_START, false)?
     .visit_field::<i8>("m_zone_flag", Self::VT_M_ZONE_FLAG, false)?
     .finish();
    Ok(())
  }
}
pub struct MarshalZoneArgs {
    pub m_zone_start: f32,
    pub m_zone_flag: i8,
}
impl<'a> Default for MarshalZoneArgs {
  #[inline]
  fn default() -> Self {
    MarshalZoneArgs {
      m_zone_start: 0.0,
      m_zone_flag: 0,
    }
  }
}

pub struct MarshalZoneBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MarshalZoneBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_zone_start(&mut self, m_zone_start: f32) {
    self.fbb_.push_slot::<f32>(MarshalZone::VT_M_ZONE_START, m_zone_start, 0.0);
  }
  #[inline]
  pub fn add_m_zone_flag(&mut self, m_zone_flag: i8) {
    self.fbb_.push_slot::<i8>(MarshalZone::VT_M_ZONE_FLAG, m_zone_flag, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MarshalZoneBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MarshalZoneBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MarshalZone<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MarshalZone<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MarshalZone");
      ds.field("m_zone_start", &self.m_zone_start());
      ds.field("m_zone_flag", &self.m_zone_flag());
      ds.finish()
  }
}
pub enum WeatherForecastSampleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WeatherForecastSample<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WeatherForecastSample<'a> {
  type Inner = WeatherForecastSample<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WeatherForecastSample<'a> {
  pub const VT_M_SESSION_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_M_TIME_OFFSET: flatbuffers::VOffsetT = 6;
  pub const VT_M_WEATHER: flatbuffers::VOffsetT = 8;
  pub const VT_M_TRACK_TEMPERATURE: flatbuffers::VOffsetT = 10;
  pub const VT_M_TRACK_TEMPERATURE_CHANGE: flatbuffers::VOffsetT = 12;
  pub const VT_M_AIR_TEMPERATURE: flatbuffers::VOffsetT = 14;
  pub const VT_M_AIR_TEMPERATURE_CHANGE: flatbuffers::VOffsetT = 16;
  pub const VT_M_RAIN_PERCENTAGE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WeatherForecastSample { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WeatherForecastSampleArgs
  ) -> flatbuffers::WIPOffset<WeatherForecastSample<'bldr>> {
    let mut builder = WeatherForecastSampleBuilder::new(_fbb);
    builder.add_m_rain_percentage(args.m_rain_percentage);
    builder.add_m_air_temperature_change(args.m_air_temperature_change);
    builder.add_m_air_temperature(args.m_air_temperature);
    builder.add_m_track_temperature_change(args.m_track_temperature_change);
    builder.add_m_track_temperature(args.m_track_temperature);
    builder.add_m_weather(args.m_weather);
    builder.add_m_time_offset(args.m_time_offset);
    builder.add_m_session_type(args.m_session_type);
    builder.finish()
  }


  #[inline]
  pub fn m_session_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WeatherForecastSample::VT_M_SESSION_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_time_offset(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WeatherForecastSample::VT_M_TIME_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_weather(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WeatherForecastSample::VT_M_WEATHER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_track_temperature(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(WeatherForecastSample::VT_M_TRACK_TEMPERATURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_track_temperature_change(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(WeatherForecastSample::VT_M_TRACK_TEMPERATURE_CHANGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_air_temperature(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(WeatherForecastSample::VT_M_AIR_TEMPERATURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_air_temperature_change(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(WeatherForecastSample::VT_M_AIR_TEMPERATURE_CHANGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_rain_percentage(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(WeatherForecastSample::VT_M_RAIN_PERCENTAGE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for WeatherForecastSample<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_session_type", Self::VT_M_SESSION_TYPE, false)?
     .visit_field::<u8>("m_time_offset", Self::VT_M_TIME_OFFSET, false)?
     .visit_field::<u8>("m_weather", Self::VT_M_WEATHER, false)?
     .visit_field::<i8>("m_track_temperature", Self::VT_M_TRACK_TEMPERATURE, false)?
     .visit_field::<i8>("m_track_temperature_change", Self::VT_M_TRACK_TEMPERATURE_CHANGE, false)?
     .visit_field::<i8>("m_air_temperature", Self::VT_M_AIR_TEMPERATURE, false)?
     .visit_field::<i8>("m_air_temperature_change", Self::VT_M_AIR_TEMPERATURE_CHANGE, false)?
     .visit_field::<u8>("m_rain_percentage", Self::VT_M_RAIN_PERCENTAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct WeatherForecastSampleArgs {
    pub m_session_type: u8,
    pub m_time_offset: u8,
    pub m_weather: u8,
    pub m_track_temperature: i8,
    pub m_track_temperature_change: i8,
    pub m_air_temperature: i8,
    pub m_air_temperature_change: i8,
    pub m_rain_percentage: u8,
}
impl<'a> Default for WeatherForecastSampleArgs {
  #[inline]
  fn default() -> Self {
    WeatherForecastSampleArgs {
      m_session_type: 0,
      m_time_offset: 0,
      m_weather: 0,
      m_track_temperature: 0,
      m_track_temperature_change: 0,
      m_air_temperature: 0,
      m_air_temperature_change: 0,
      m_rain_percentage: 0,
    }
  }
}

pub struct WeatherForecastSampleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WeatherForecastSampleBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_session_type(&mut self, m_session_type: u8) {
    self.fbb_.push_slot::<u8>(WeatherForecastSample::VT_M_SESSION_TYPE, m_session_type, 0);
  }
  #[inline]
  pub fn add_m_time_offset(&mut self, m_time_offset: u8) {
    self.fbb_.push_slot::<u8>(WeatherForecastSample::VT_M_TIME_OFFSET, m_time_offset, 0);
  }
  #[inline]
  pub fn add_m_weather(&mut self, m_weather: u8) {
    self.fbb_.push_slot::<u8>(WeatherForecastSample::VT_M_WEATHER, m_weather, 0);
  }
  #[inline]
  pub fn add_m_track_temperature(&mut self, m_track_temperature: i8) {
    self.fbb_.push_slot::<i8>(WeatherForecastSample::VT_M_TRACK_TEMPERATURE, m_track_temperature, 0);
  }
  #[inline]
  pub fn add_m_track_temperature_change(&mut self, m_track_temperature_change: i8) {
    self.fbb_.push_slot::<i8>(WeatherForecastSample::VT_M_TRACK_TEMPERATURE_CHANGE, m_track_temperature_change, 0);
  }
  #[inline]
  pub fn add_m_air_temperature(&mut self, m_air_temperature: i8) {
    self.fbb_.push_slot::<i8>(WeatherForecastSample::VT_M_AIR_TEMPERATURE, m_air_temperature, 0);
  }
  #[inline]
  pub fn add_m_air_temperature_change(&mut self, m_air_temperature_change: i8) {
    self.fbb_.push_slot::<i8>(WeatherForecastSample::VT_M_AIR_TEMPERATURE_CHANGE, m_air_temperature_change, 0);
  }
  #[inline]
  pub fn add_m_rain_percentage(&mut self, m_rain_percentage: u8) {
    self.fbb_.push_slot::<u8>(WeatherForecastSample::VT_M_RAIN_PERCENTAGE, m_rain_percentage, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WeatherForecastSampleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WeatherForecastSampleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WeatherForecastSample<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WeatherForecastSample<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WeatherForecastSample");
      ds.field("m_session_type", &self.m_session_type());
      ds.field("m_time_offset", &self.m_time_offset());
      ds.field("m_weather", &self.m_weather());
      ds.field("m_track_temperature", &self.m_track_temperature());
      ds.field("m_track_temperature_change", &self.m_track_temperature_change());
      ds.field("m_air_temperature", &self.m_air_temperature());
      ds.field("m_air_temperature_change", &self.m_air_temperature_change());
      ds.field("m_rain_percentage", &self.m_rain_percentage());
      ds.finish()
  }
}
pub enum PacketSessionDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PacketSessionData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PacketSessionData<'a> {
  type Inner = PacketSessionData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PacketSessionData<'a> {
  pub const VT_M_WEATHER: flatbuffers::VOffsetT = 4;
  pub const VT_M_TRACK_TEMPERATURE: flatbuffers::VOffsetT = 6;
  pub const VT_M_AIR_TEMPERATURE: flatbuffers::VOffsetT = 8;
  pub const VT_M_TOTAL_LAPS: flatbuffers::VOffsetT = 10;
  pub const VT_M_TRACK_LENGTH: flatbuffers::VOffsetT = 12;
  pub const VT_M_SESSION_TYPE: flatbuffers::VOffsetT = 14;
  pub const VT_M_TRACK_ID: flatbuffers::VOffsetT = 16;
  pub const VT_M_FORMULA: flatbuffers::VOffsetT = 18;
  pub const VT_M_SESSION_TIME_LEFT: flatbuffers::VOffsetT = 20;
  pub const VT_M_SESSION_DURATION: flatbuffers::VOffsetT = 22;
  pub const VT_M_PIT_SPEED_LIMIT: flatbuffers::VOffsetT = 24;
  pub const VT_M_GAME_PAUSED: flatbuffers::VOffsetT = 26;
  pub const VT_M_IS_SPECTATING: flatbuffers::VOffsetT = 28;
  pub const VT_M_SPECTATOR_CAR_INDEX: flatbuffers::VOffsetT = 30;
  pub const VT_M_SLI_PRO_NATIVE_SUPPORT: flatbuffers::VOffsetT = 32;
  pub const VT_M_NUM_MARSHAL_ZONES: flatbuffers::VOffsetT = 34;
  pub const VT_M_MARSHAL_ZONES: flatbuffers::VOffsetT = 36;
  pub const VT_M_SAFETY_CAR_STATUS: flatbuffers::VOffsetT = 38;
  pub const VT_M_NETWORK_GAME: flatbuffers::VOffsetT = 40;
  pub const VT_M_NUM_WEATHER_FORECAST_SAMPLES: flatbuffers::VOffsetT = 42;
  pub const VT_M_WEATHER_FORECAST_SAMPLES: flatbuffers::VOffsetT = 44;
  pub const VT_M_FORECAST_ACCURACY: flatbuffers::VOffsetT = 46;
  pub const VT_M_AI_DIFFICULTY: flatbuffers::VOffsetT = 48;
  pub const VT_M_SEASON_LINK_IDENTIFIER: flatbuffers::VOffsetT = 50;
  pub const VT_M_WEEKEND_LINK_IDENTIFIER: flatbuffers::VOffsetT = 52;
  pub const VT_M_SESSION_LINK_IDENTIFIER: flatbuffers::VOffsetT = 54;
  pub const VT_M_PIT_STOP_WINDOW_IDEAL_LAP: flatbuffers::VOffsetT = 56;
  pub const VT_M_PIT_STOP_WINDOW_LATEST_LAP: flatbuffers::VOffsetT = 58;
  pub const VT_M_PIT_STOP_REJOIN_POSITION: flatbuffers::VOffsetT = 60;
  pub const VT_M_STEERING_ASSIST: flatbuffers::VOffsetT = 62;
  pub const VT_M_BRAKING_ASSIST: flatbuffers::VOffsetT = 64;
  pub const VT_M_GEARBOX_ASSIST: flatbuffers::VOffsetT = 66;
  pub const VT_M_PIT_ASSIST: flatbuffers::VOffsetT = 68;
  pub const VT_M_PIT_RELEASE_ASSIST: flatbuffers::VOffsetT = 70;
  pub const VT_M_ERS_ASSIST: flatbuffers::VOffsetT = 72;
  pub const VT_M_DRS_ASSIST: flatbuffers::VOffsetT = 74;
  pub const VT_M_DYNAMIC_RACING_LINE: flatbuffers::VOffsetT = 76;
  pub const VT_M_DYNAMIC_RACING_LINE_TYPE: flatbuffers::VOffsetT = 78;
  pub const VT_M_GAME_MODE: flatbuffers::VOffsetT = 80;
  pub const VT_M_RULE_SET: flatbuffers::VOffsetT = 82;
  pub const VT_M_TIME_OF_DAY: flatbuffers::VOffsetT = 84;
  pub const VT_M_SESSION_LENGTH: flatbuffers::VOffsetT = 86;
  pub const VT_M_SPEED_UNITS_LEAD_PLAYER: flatbuffers::VOffsetT = 88;
  pub const VT_M_TEMPERATURE_UNITS_LEAD_PLAYER: flatbuffers::VOffsetT = 90;
  pub const VT_M_SPEED_UNITS_SECONDARY_PLAYER: flatbuffers::VOffsetT = 92;
  pub const VT_M_TEMPERATURE_INITS_SECONDARY_PLAYER: flatbuffers::VOffsetT = 94;
  pub const VT_M_NUM_SAFETY_CAR_PERIODS: flatbuffers::VOffsetT = 96;
  pub const VT_M_NUM_VIRTUAL_SAFETY_CAR_PERIODS: flatbuffers::VOffsetT = 98;
  pub const VT_M_NUM_RED_FLAG_PERIODS: flatbuffers::VOffsetT = 100;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PacketSessionData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PacketSessionDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PacketSessionData<'bldr>> {
    let mut builder = PacketSessionDataBuilder::new(_fbb);
    builder.add_m_time_of_day(args.m_time_of_day);
    builder.add_m_session_link_identifier(args.m_session_link_identifier);
    builder.add_m_weekend_link_identifier(args.m_weekend_link_identifier);
    builder.add_m_season_link_identifier(args.m_season_link_identifier);
    if let Some(x) = args.m_weather_forecast_samples { builder.add_m_weather_forecast_samples(x); }
    if let Some(x) = args.m_marshal_zones { builder.add_m_marshal_zones(x); }
    builder.add_m_session_duration(args.m_session_duration);
    builder.add_m_session_time_left(args.m_session_time_left);
    builder.add_m_track_length(args.m_track_length);
    builder.add_m_num_red_flag_periods(args.m_num_red_flag_periods);
    builder.add_m_num_virtual_safety_car_periods(args.m_num_virtual_safety_car_periods);
    builder.add_m_num_safety_car_periods(args.m_num_safety_car_periods);
    builder.add_m_temperature_inits_secondary_player(args.m_temperature_inits_secondary_player);
    builder.add_m_speed_units_secondary_player(args.m_speed_units_secondary_player);
    builder.add_m_temperature_units_lead_player(args.m_temperature_units_lead_player);
    builder.add_m_speed_units_lead_player(args.m_speed_units_lead_player);
    builder.add_m_session_length(args.m_session_length);
    builder.add_m_rule_set(args.m_rule_set);
    builder.add_m_game_mode(args.m_game_mode);
    builder.add_m_dynamic_racing_line_type(args.m_dynamic_racing_line_type);
    builder.add_m_dynamic_racing_line(args.m_dynamic_racing_line);
    builder.add_m_drs_assist(args.m_drs_assist);
    builder.add_m_ers_assist(args.m_ers_assist);
    builder.add_m_pit_release_assist(args.m_pit_release_assist);
    builder.add_m_pit_assist(args.m_pit_assist);
    builder.add_m_gearbox_assist(args.m_gearbox_assist);
    builder.add_m_braking_assist(args.m_braking_assist);
    builder.add_m_steering_assist(args.m_steering_assist);
    builder.add_m_pit_stop_rejoin_position(args.m_pit_stop_rejoin_position);
    builder.add_m_pit_stop_window_latest_lap(args.m_pit_stop_window_latest_lap);
    builder.add_m_pit_stop_window_ideal_lap(args.m_pit_stop_window_ideal_lap);
    builder.add_m_ai_difficulty(args.m_ai_difficulty);
    builder.add_m_forecast_accuracy(args.m_forecast_accuracy);
    builder.add_m_num_weather_forecast_samples(args.m_num_weather_forecast_samples);
    builder.add_m_network_game(args.m_network_game);
    builder.add_m_safety_car_status(args.m_safety_car_status);
    builder.add_m_num_marshal_zones(args.m_num_marshal_zones);
    builder.add_m_sli_pro_native_support(args.m_sli_pro_native_support);
    builder.add_m_spectator_car_index(args.m_spectator_car_index);
    builder.add_m_is_spectating(args.m_is_spectating);
    builder.add_m_game_paused(args.m_game_paused);
    builder.add_m_pit_speed_limit(args.m_pit_speed_limit);
    builder.add_m_formula(args.m_formula);
    builder.add_m_track_id(args.m_track_id);
    builder.add_m_session_type(args.m_session_type);
    builder.add_m_total_laps(args.m_total_laps);
    builder.add_m_air_temperature(args.m_air_temperature);
    builder.add_m_track_temperature(args.m_track_temperature);
    builder.add_m_weather(args.m_weather);
    builder.finish()
  }


  #[inline]
  pub fn m_weather(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_WEATHER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_track_temperature(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PacketSessionData::VT_M_TRACK_TEMPERATURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_air_temperature(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PacketSessionData::VT_M_AIR_TEMPERATURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_total_laps(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_TOTAL_LAPS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_track_length(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PacketSessionData::VT_M_TRACK_LENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_session_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SESSION_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_track_id(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PacketSessionData::VT_M_TRACK_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_formula(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_FORMULA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_session_time_left(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PacketSessionData::VT_M_SESSION_TIME_LEFT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_session_duration(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(PacketSessionData::VT_M_SESSION_DURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_speed_limit(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_SPEED_LIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_game_paused(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_GAME_PAUSED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_is_spectating(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_IS_SPECTATING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_spectator_car_index(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SPECTATOR_CAR_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_sli_pro_native_support(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SLI_PRO_NATIVE_SUPPORT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_marshal_zones(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NUM_MARSHAL_ZONES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_marshal_zones(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MarshalZone<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MarshalZone>>>>(PacketSessionData::VT_M_MARSHAL_ZONES, None)}
  }
  #[inline]
  pub fn m_safety_car_status(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SAFETY_CAR_STATUS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_network_game(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NETWORK_GAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_weather_forecast_samples(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NUM_WEATHER_FORECAST_SAMPLES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_weather_forecast_samples(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WeatherForecastSample<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WeatherForecastSample>>>>(PacketSessionData::VT_M_WEATHER_FORECAST_SAMPLES, None)}
  }
  #[inline]
  pub fn m_forecast_accuracy(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_FORECAST_ACCURACY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_ai_difficulty(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_AI_DIFFICULTY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_season_link_identifier(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PacketSessionData::VT_M_SEASON_LINK_IDENTIFIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_weekend_link_identifier(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PacketSessionData::VT_M_WEEKEND_LINK_IDENTIFIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_session_link_identifier(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PacketSessionData::VT_M_SESSION_LINK_IDENTIFIER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_stop_window_ideal_lap(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_STOP_WINDOW_IDEAL_LAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_stop_window_latest_lap(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_STOP_WINDOW_LATEST_LAP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_stop_rejoin_position(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_STOP_REJOIN_POSITION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_steering_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_STEERING_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_braking_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_BRAKING_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_gearbox_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_GEARBOX_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_pit_release_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_PIT_RELEASE_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_ers_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_ERS_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_drs_assist(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_DRS_ASSIST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_dynamic_racing_line(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_DYNAMIC_RACING_LINE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_dynamic_racing_line_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_DYNAMIC_RACING_LINE_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_game_mode(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_GAME_MODE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_rule_set(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_RULE_SET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_time_of_day(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(PacketSessionData::VT_M_TIME_OF_DAY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_session_length(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SESSION_LENGTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_speed_units_lead_player(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SPEED_UNITS_LEAD_PLAYER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_temperature_units_lead_player(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_TEMPERATURE_UNITS_LEAD_PLAYER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_speed_units_secondary_player(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_SPEED_UNITS_SECONDARY_PLAYER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_temperature_inits_secondary_player(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_TEMPERATURE_INITS_SECONDARY_PLAYER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_safety_car_periods(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NUM_SAFETY_CAR_PERIODS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_virtual_safety_car_periods(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NUM_VIRTUAL_SAFETY_CAR_PERIODS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn m_num_red_flag_periods(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(PacketSessionData::VT_M_NUM_RED_FLAG_PERIODS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PacketSessionData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("m_weather", Self::VT_M_WEATHER, false)?
     .visit_field::<i8>("m_track_temperature", Self::VT_M_TRACK_TEMPERATURE, false)?
     .visit_field::<i8>("m_air_temperature", Self::VT_M_AIR_TEMPERATURE, false)?
     .visit_field::<u8>("m_total_laps", Self::VT_M_TOTAL_LAPS, false)?
     .visit_field::<u16>("m_track_length", Self::VT_M_TRACK_LENGTH, false)?
     .visit_field::<u8>("m_session_type", Self::VT_M_SESSION_TYPE, false)?
     .visit_field::<i8>("m_track_id", Self::VT_M_TRACK_ID, false)?
     .visit_field::<u8>("m_formula", Self::VT_M_FORMULA, false)?
     .visit_field::<u16>("m_session_time_left", Self::VT_M_SESSION_TIME_LEFT, false)?
     .visit_field::<u16>("m_session_duration", Self::VT_M_SESSION_DURATION, false)?
     .visit_field::<u8>("m_pit_speed_limit", Self::VT_M_PIT_SPEED_LIMIT, false)?
     .visit_field::<u8>("m_game_paused", Self::VT_M_GAME_PAUSED, false)?
     .visit_field::<u8>("m_is_spectating", Self::VT_M_IS_SPECTATING, false)?
     .visit_field::<u8>("m_spectator_car_index", Self::VT_M_SPECTATOR_CAR_INDEX, false)?
     .visit_field::<u8>("m_sli_pro_native_support", Self::VT_M_SLI_PRO_NATIVE_SUPPORT, false)?
     .visit_field::<u8>("m_num_marshal_zones", Self::VT_M_NUM_MARSHAL_ZONES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MarshalZone>>>>("m_marshal_zones", Self::VT_M_MARSHAL_ZONES, false)?
     .visit_field::<u8>("m_safety_car_status", Self::VT_M_SAFETY_CAR_STATUS, false)?
     .visit_field::<u8>("m_network_game", Self::VT_M_NETWORK_GAME, false)?
     .visit_field::<u8>("m_num_weather_forecast_samples", Self::VT_M_NUM_WEATHER_FORECAST_SAMPLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<WeatherForecastSample>>>>("m_weather_forecast_samples", Self::VT_M_WEATHER_FORECAST_SAMPLES, false)?
     .visit_field::<u8>("m_forecast_accuracy", Self::VT_M_FORECAST_ACCURACY, false)?
     .visit_field::<u8>("m_ai_difficulty", Self::VT_M_AI_DIFFICULTY, false)?
     .visit_field::<u32>("m_season_link_identifier", Self::VT_M_SEASON_LINK_IDENTIFIER, false)?
     .visit_field::<u32>("m_weekend_link_identifier", Self::VT_M_WEEKEND_LINK_IDENTIFIER, false)?
     .visit_field::<u32>("m_session_link_identifier", Self::VT_M_SESSION_LINK_IDENTIFIER, false)?
     .visit_field::<u8>("m_pit_stop_window_ideal_lap", Self::VT_M_PIT_STOP_WINDOW_IDEAL_LAP, false)?
     .visit_field::<u8>("m_pit_stop_window_latest_lap", Self::VT_M_PIT_STOP_WINDOW_LATEST_LAP, false)?
     .visit_field::<u8>("m_pit_stop_rejoin_position", Self::VT_M_PIT_STOP_REJOIN_POSITION, false)?
     .visit_field::<u8>("m_steering_assist", Self::VT_M_STEERING_ASSIST, false)?
     .visit_field::<u8>("m_braking_assist", Self::VT_M_BRAKING_ASSIST, false)?
     .visit_field::<u8>("m_gearbox_assist", Self::VT_M_GEARBOX_ASSIST, false)?
     .visit_field::<u8>("m_pit_assist", Self::VT_M_PIT_ASSIST, false)?
     .visit_field::<u8>("m_pit_release_assist", Self::VT_M_PIT_RELEASE_ASSIST, false)?
     .visit_field::<u8>("m_ers_assist", Self::VT_M_ERS_ASSIST, false)?
     .visit_field::<u8>("m_drs_assist", Self::VT_M_DRS_ASSIST, false)?
     .visit_field::<u8>("m_dynamic_racing_line", Self::VT_M_DYNAMIC_RACING_LINE, false)?
     .visit_field::<u8>("m_dynamic_racing_line_type", Self::VT_M_DYNAMIC_RACING_LINE_TYPE, false)?
     .visit_field::<u8>("m_game_mode", Self::VT_M_GAME_MODE, false)?
     .visit_field::<u8>("m_rule_set", Self::VT_M_RULE_SET, false)?
     .visit_field::<u32>("m_time_of_day", Self::VT_M_TIME_OF_DAY, false)?
     .visit_field::<u8>("m_session_length", Self::VT_M_SESSION_LENGTH, false)?
     .visit_field::<u8>("m_speed_units_lead_player", Self::VT_M_SPEED_UNITS_LEAD_PLAYER, false)?
     .visit_field::<u8>("m_temperature_units_lead_player", Self::VT_M_TEMPERATURE_UNITS_LEAD_PLAYER, false)?
     .visit_field::<u8>("m_speed_units_secondary_player", Self::VT_M_SPEED_UNITS_SECONDARY_PLAYER, false)?
     .visit_field::<u8>("m_temperature_inits_secondary_player", Self::VT_M_TEMPERATURE_INITS_SECONDARY_PLAYER, false)?
     .visit_field::<u8>("m_num_safety_car_periods", Self::VT_M_NUM_SAFETY_CAR_PERIODS, false)?
     .visit_field::<u8>("m_num_virtual_safety_car_periods", Self::VT_M_NUM_VIRTUAL_SAFETY_CAR_PERIODS, false)?
     .visit_field::<u8>("m_num_red_flag_periods", Self::VT_M_NUM_RED_FLAG_PERIODS, false)?
     .finish();
    Ok(())
  }
}
pub struct PacketSessionDataArgs<'a> {
    pub m_weather: u8,
    pub m_track_temperature: i8,
    pub m_air_temperature: i8,
    pub m_total_laps: u8,
    pub m_track_length: u16,
    pub m_session_type: u8,
    pub m_track_id: i8,
    pub m_formula: u8,
    pub m_session_time_left: u16,
    pub m_session_duration: u16,
    pub m_pit_speed_limit: u8,
    pub m_game_paused: u8,
    pub m_is_spectating: u8,
    pub m_spectator_car_index: u8,
    pub m_sli_pro_native_support: u8,
    pub m_num_marshal_zones: u8,
    pub m_marshal_zones: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MarshalZone<'a>>>>>,
    pub m_safety_car_status: u8,
    pub m_network_game: u8,
    pub m_num_weather_forecast_samples: u8,
    pub m_weather_forecast_samples: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<WeatherForecastSample<'a>>>>>,
    pub m_forecast_accuracy: u8,
    pub m_ai_difficulty: u8,
    pub m_season_link_identifier: u32,
    pub m_weekend_link_identifier: u32,
    pub m_session_link_identifier: u32,
    pub m_pit_stop_window_ideal_lap: u8,
    pub m_pit_stop_window_latest_lap: u8,
    pub m_pit_stop_rejoin_position: u8,
    pub m_steering_assist: u8,
    pub m_braking_assist: u8,
    pub m_gearbox_assist: u8,
    pub m_pit_assist: u8,
    pub m_pit_release_assist: u8,
    pub m_ers_assist: u8,
    pub m_drs_assist: u8,
    pub m_dynamic_racing_line: u8,
    pub m_dynamic_racing_line_type: u8,
    pub m_game_mode: u8,
    pub m_rule_set: u8,
    pub m_time_of_day: u32,
    pub m_session_length: u8,
    pub m_speed_units_lead_player: u8,
    pub m_temperature_units_lead_player: u8,
    pub m_speed_units_secondary_player: u8,
    pub m_temperature_inits_secondary_player: u8,
    pub m_num_safety_car_periods: u8,
    pub m_num_virtual_safety_car_periods: u8,
    pub m_num_red_flag_periods: u8,
}
impl<'a> Default for PacketSessionDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PacketSessionDataArgs {
      m_weather: 0,
      m_track_temperature: 0,
      m_air_temperature: 0,
      m_total_laps: 0,
      m_track_length: 0,
      m_session_type: 0,
      m_track_id: 0,
      m_formula: 0,
      m_session_time_left: 0,
      m_session_duration: 0,
      m_pit_speed_limit: 0,
      m_game_paused: 0,
      m_is_spectating: 0,
      m_spectator_car_index: 0,
      m_sli_pro_native_support: 0,
      m_num_marshal_zones: 0,
      m_marshal_zones: None,
      m_safety_car_status: 0,
      m_network_game: 0,
      m_num_weather_forecast_samples: 0,
      m_weather_forecast_samples: None,
      m_forecast_accuracy: 0,
      m_ai_difficulty: 0,
      m_season_link_identifier: 0,
      m_weekend_link_identifier: 0,
      m_session_link_identifier: 0,
      m_pit_stop_window_ideal_lap: 0,
      m_pit_stop_window_latest_lap: 0,
      m_pit_stop_rejoin_position: 0,
      m_steering_assist: 0,
      m_braking_assist: 0,
      m_gearbox_assist: 0,
      m_pit_assist: 0,
      m_pit_release_assist: 0,
      m_ers_assist: 0,
      m_drs_assist: 0,
      m_dynamic_racing_line: 0,
      m_dynamic_racing_line_type: 0,
      m_game_mode: 0,
      m_rule_set: 0,
      m_time_of_day: 0,
      m_session_length: 0,
      m_speed_units_lead_player: 0,
      m_temperature_units_lead_player: 0,
      m_speed_units_secondary_player: 0,
      m_temperature_inits_secondary_player: 0,
      m_num_safety_car_periods: 0,
      m_num_virtual_safety_car_periods: 0,
      m_num_red_flag_periods: 0,
    }
  }
}

pub struct PacketSessionDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketSessionDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_m_weather(&mut self, m_weather: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_WEATHER, m_weather, 0);
  }
  #[inline]
  pub fn add_m_track_temperature(&mut self, m_track_temperature: i8) {
    self.fbb_.push_slot::<i8>(PacketSessionData::VT_M_TRACK_TEMPERATURE, m_track_temperature, 0);
  }
  #[inline]
  pub fn add_m_air_temperature(&mut self, m_air_temperature: i8) {
    self.fbb_.push_slot::<i8>(PacketSessionData::VT_M_AIR_TEMPERATURE, m_air_temperature, 0);
  }
  #[inline]
  pub fn add_m_total_laps(&mut self, m_total_laps: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_TOTAL_LAPS, m_total_laps, 0);
  }
  #[inline]
  pub fn add_m_track_length(&mut self, m_track_length: u16) {
    self.fbb_.push_slot::<u16>(PacketSessionData::VT_M_TRACK_LENGTH, m_track_length, 0);
  }
  #[inline]
  pub fn add_m_session_type(&mut self, m_session_type: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SESSION_TYPE, m_session_type, 0);
  }
  #[inline]
  pub fn add_m_track_id(&mut self, m_track_id: i8) {
    self.fbb_.push_slot::<i8>(PacketSessionData::VT_M_TRACK_ID, m_track_id, 0);
  }
  #[inline]
  pub fn add_m_formula(&mut self, m_formula: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_FORMULA, m_formula, 0);
  }
  #[inline]
  pub fn add_m_session_time_left(&mut self, m_session_time_left: u16) {
    self.fbb_.push_slot::<u16>(PacketSessionData::VT_M_SESSION_TIME_LEFT, m_session_time_left, 0);
  }
  #[inline]
  pub fn add_m_session_duration(&mut self, m_session_duration: u16) {
    self.fbb_.push_slot::<u16>(PacketSessionData::VT_M_SESSION_DURATION, m_session_duration, 0);
  }
  #[inline]
  pub fn add_m_pit_speed_limit(&mut self, m_pit_speed_limit: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_SPEED_LIMIT, m_pit_speed_limit, 0);
  }
  #[inline]
  pub fn add_m_game_paused(&mut self, m_game_paused: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_GAME_PAUSED, m_game_paused, 0);
  }
  #[inline]
  pub fn add_m_is_spectating(&mut self, m_is_spectating: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_IS_SPECTATING, m_is_spectating, 0);
  }
  #[inline]
  pub fn add_m_spectator_car_index(&mut self, m_spectator_car_index: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SPECTATOR_CAR_INDEX, m_spectator_car_index, 0);
  }
  #[inline]
  pub fn add_m_sli_pro_native_support(&mut self, m_sli_pro_native_support: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SLI_PRO_NATIVE_SUPPORT, m_sli_pro_native_support, 0);
  }
  #[inline]
  pub fn add_m_num_marshal_zones(&mut self, m_num_marshal_zones: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NUM_MARSHAL_ZONES, m_num_marshal_zones, 0);
  }
  #[inline]
  pub fn add_m_marshal_zones(&mut self, m_marshal_zones: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MarshalZone<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketSessionData::VT_M_MARSHAL_ZONES, m_marshal_zones);
  }
  #[inline]
  pub fn add_m_safety_car_status(&mut self, m_safety_car_status: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SAFETY_CAR_STATUS, m_safety_car_status, 0);
  }
  #[inline]
  pub fn add_m_network_game(&mut self, m_network_game: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NETWORK_GAME, m_network_game, 0);
  }
  #[inline]
  pub fn add_m_num_weather_forecast_samples(&mut self, m_num_weather_forecast_samples: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NUM_WEATHER_FORECAST_SAMPLES, m_num_weather_forecast_samples, 0);
  }
  #[inline]
  pub fn add_m_weather_forecast_samples(&mut self, m_weather_forecast_samples: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<WeatherForecastSample<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PacketSessionData::VT_M_WEATHER_FORECAST_SAMPLES, m_weather_forecast_samples);
  }
  #[inline]
  pub fn add_m_forecast_accuracy(&mut self, m_forecast_accuracy: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_FORECAST_ACCURACY, m_forecast_accuracy, 0);
  }
  #[inline]
  pub fn add_m_ai_difficulty(&mut self, m_ai_difficulty: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_AI_DIFFICULTY, m_ai_difficulty, 0);
  }
  #[inline]
  pub fn add_m_season_link_identifier(&mut self, m_season_link_identifier: u32) {
    self.fbb_.push_slot::<u32>(PacketSessionData::VT_M_SEASON_LINK_IDENTIFIER, m_season_link_identifier, 0);
  }
  #[inline]
  pub fn add_m_weekend_link_identifier(&mut self, m_weekend_link_identifier: u32) {
    self.fbb_.push_slot::<u32>(PacketSessionData::VT_M_WEEKEND_LINK_IDENTIFIER, m_weekend_link_identifier, 0);
  }
  #[inline]
  pub fn add_m_session_link_identifier(&mut self, m_session_link_identifier: u32) {
    self.fbb_.push_slot::<u32>(PacketSessionData::VT_M_SESSION_LINK_IDENTIFIER, m_session_link_identifier, 0);
  }
  #[inline]
  pub fn add_m_pit_stop_window_ideal_lap(&mut self, m_pit_stop_window_ideal_lap: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_STOP_WINDOW_IDEAL_LAP, m_pit_stop_window_ideal_lap, 0);
  }
  #[inline]
  pub fn add_m_pit_stop_window_latest_lap(&mut self, m_pit_stop_window_latest_lap: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_STOP_WINDOW_LATEST_LAP, m_pit_stop_window_latest_lap, 0);
  }
  #[inline]
  pub fn add_m_pit_stop_rejoin_position(&mut self, m_pit_stop_rejoin_position: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_STOP_REJOIN_POSITION, m_pit_stop_rejoin_position, 0);
  }
  #[inline]
  pub fn add_m_steering_assist(&mut self, m_steering_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_STEERING_ASSIST, m_steering_assist, 0);
  }
  #[inline]
  pub fn add_m_braking_assist(&mut self, m_braking_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_BRAKING_ASSIST, m_braking_assist, 0);
  }
  #[inline]
  pub fn add_m_gearbox_assist(&mut self, m_gearbox_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_GEARBOX_ASSIST, m_gearbox_assist, 0);
  }
  #[inline]
  pub fn add_m_pit_assist(&mut self, m_pit_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_ASSIST, m_pit_assist, 0);
  }
  #[inline]
  pub fn add_m_pit_release_assist(&mut self, m_pit_release_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_PIT_RELEASE_ASSIST, m_pit_release_assist, 0);
  }
  #[inline]
  pub fn add_m_ers_assist(&mut self, m_ers_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_ERS_ASSIST, m_ers_assist, 0);
  }
  #[inline]
  pub fn add_m_drs_assist(&mut self, m_drs_assist: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_DRS_ASSIST, m_drs_assist, 0);
  }
  #[inline]
  pub fn add_m_dynamic_racing_line(&mut self, m_dynamic_racing_line: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_DYNAMIC_RACING_LINE, m_dynamic_racing_line, 0);
  }
  #[inline]
  pub fn add_m_dynamic_racing_line_type(&mut self, m_dynamic_racing_line_type: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_DYNAMIC_RACING_LINE_TYPE, m_dynamic_racing_line_type, 0);
  }
  #[inline]
  pub fn add_m_game_mode(&mut self, m_game_mode: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_GAME_MODE, m_game_mode, 0);
  }
  #[inline]
  pub fn add_m_rule_set(&mut self, m_rule_set: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_RULE_SET, m_rule_set, 0);
  }
  #[inline]
  pub fn add_m_time_of_day(&mut self, m_time_of_day: u32) {
    self.fbb_.push_slot::<u32>(PacketSessionData::VT_M_TIME_OF_DAY, m_time_of_day, 0);
  }
  #[inline]
  pub fn add_m_session_length(&mut self, m_session_length: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SESSION_LENGTH, m_session_length, 0);
  }
  #[inline]
  pub fn add_m_speed_units_lead_player(&mut self, m_speed_units_lead_player: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SPEED_UNITS_LEAD_PLAYER, m_speed_units_lead_player, 0);
  }
  #[inline]
  pub fn add_m_temperature_units_lead_player(&mut self, m_temperature_units_lead_player: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_TEMPERATURE_UNITS_LEAD_PLAYER, m_temperature_units_lead_player, 0);
  }
  #[inline]
  pub fn add_m_speed_units_secondary_player(&mut self, m_speed_units_secondary_player: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_SPEED_UNITS_SECONDARY_PLAYER, m_speed_units_secondary_player, 0);
  }
  #[inline]
  pub fn add_m_temperature_inits_secondary_player(&mut self, m_temperature_inits_secondary_player: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_TEMPERATURE_INITS_SECONDARY_PLAYER, m_temperature_inits_secondary_player, 0);
  }
  #[inline]
  pub fn add_m_num_safety_car_periods(&mut self, m_num_safety_car_periods: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NUM_SAFETY_CAR_PERIODS, m_num_safety_car_periods, 0);
  }
  #[inline]
  pub fn add_m_num_virtual_safety_car_periods(&mut self, m_num_virtual_safety_car_periods: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NUM_VIRTUAL_SAFETY_CAR_PERIODS, m_num_virtual_safety_car_periods, 0);
  }
  #[inline]
  pub fn add_m_num_red_flag_periods(&mut self, m_num_red_flag_periods: u8) {
    self.fbb_.push_slot::<u8>(PacketSessionData::VT_M_NUM_RED_FLAG_PERIODS, m_num_red_flag_periods, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketSessionDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketSessionDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PacketSessionData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PacketSessionData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PacketSessionData");
      ds.field("m_weather", &self.m_weather());
      ds.field("m_track_temperature", &self.m_track_temperature());
      ds.field("m_air_temperature", &self.m_air_temperature());
      ds.field("m_total_laps", &self.m_total_laps());
      ds.field("m_track_length", &self.m_track_length());
      ds.field("m_session_type", &self.m_session_type());
      ds.field("m_track_id", &self.m_track_id());
      ds.field("m_formula", &self.m_formula());
      ds.field("m_session_time_left", &self.m_session_time_left());
      ds.field("m_session_duration", &self.m_session_duration());
      ds.field("m_pit_speed_limit", &self.m_pit_speed_limit());
      ds.field("m_game_paused", &self.m_game_paused());
      ds.field("m_is_spectating", &self.m_is_spectating());
      ds.field("m_spectator_car_index", &self.m_spectator_car_index());
      ds.field("m_sli_pro_native_support", &self.m_sli_pro_native_support());
      ds.field("m_num_marshal_zones", &self.m_num_marshal_zones());
      ds.field("m_marshal_zones", &self.m_marshal_zones());
      ds.field("m_safety_car_status", &self.m_safety_car_status());
      ds.field("m_network_game", &self.m_network_game());
      ds.field("m_num_weather_forecast_samples", &self.m_num_weather_forecast_samples());
      ds.field("m_weather_forecast_samples", &self.m_weather_forecast_samples());
      ds.field("m_forecast_accuracy", &self.m_forecast_accuracy());
      ds.field("m_ai_difficulty", &self.m_ai_difficulty());
      ds.field("m_season_link_identifier", &self.m_season_link_identifier());
      ds.field("m_weekend_link_identifier", &self.m_weekend_link_identifier());
      ds.field("m_session_link_identifier", &self.m_session_link_identifier());
      ds.field("m_pit_stop_window_ideal_lap", &self.m_pit_stop_window_ideal_lap());
      ds.field("m_pit_stop_window_latest_lap", &self.m_pit_stop_window_latest_lap());
      ds.field("m_pit_stop_rejoin_position", &self.m_pit_stop_rejoin_position());
      ds.field("m_steering_assist", &self.m_steering_assist());
      ds.field("m_braking_assist", &self.m_braking_assist());
      ds.field("m_gearbox_assist", &self.m_gearbox_assist());
      ds.field("m_pit_assist", &self.m_pit_assist());
      ds.field("m_pit_release_assist", &self.m_pit_release_assist());
      ds.field("m_ers_assist", &self.m_ers_assist());
      ds.field("m_drs_assist", &self.m_drs_assist());
      ds.field("m_dynamic_racing_line", &self.m_dynamic_racing_line());
      ds.field("m_dynamic_racing_line_type", &self.m_dynamic_racing_line_type());
      ds.field("m_game_mode", &self.m_game_mode());
      ds.field("m_rule_set", &self.m_rule_set());
      ds.field("m_time_of_day", &self.m_time_of_day());
      ds.field("m_session_length", &self.m_session_length());
      ds.field("m_speed_units_lead_player", &self.m_speed_units_lead_player());
      ds.field("m_temperature_units_lead_player", &self.m_temperature_units_lead_player());
      ds.field("m_speed_units_secondary_player", &self.m_speed_units_secondary_player());
      ds.field("m_temperature_inits_secondary_player", &self.m_temperature_inits_secondary_player());
      ds.field("m_num_safety_car_periods", &self.m_num_safety_car_periods());
      ds.field("m_num_virtual_safety_car_periods", &self.m_num_virtual_safety_car_periods());
      ds.field("m_num_red_flag_periods", &self.m_num_red_flag_periods());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `PacketSessionData`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_data_unchecked`.
pub fn root_as_packet_session_data(buf: &[u8]) -> Result<PacketSessionData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<PacketSessionData>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `PacketSessionData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_packet_session_data_unchecked`.
pub fn size_prefixed_root_as_packet_session_data(buf: &[u8]) -> Result<PacketSessionData, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<PacketSessionData>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `PacketSessionData` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_data_unchecked`.
pub fn root_as_packet_session_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketSessionData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<PacketSessionData<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `PacketSessionData` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_packet_session_data_unchecked`.
pub fn size_prefixed_root_as_packet_session_data_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<PacketSessionData<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<PacketSessionData<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a PacketSessionData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `PacketSessionData`.
pub unsafe fn root_as_packet_session_data_unchecked(buf: &[u8]) -> PacketSessionData {
  flatbuffers::root_unchecked::<PacketSessionData>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed PacketSessionData and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `PacketSessionData`.
pub unsafe fn size_prefixed_root_as_packet_session_data_unchecked(buf: &[u8]) -> PacketSessionData {
  flatbuffers::size_prefixed_root_unchecked::<PacketSessionData>(buf)
}
#[inline]
pub fn finish_packet_session_data_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<PacketSessionData<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_session_data_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<PacketSessionData<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod session_data
}  // pub mod protos

